\documentclass[a4paper,12pt]{scrartcl}


\usepackage{cite}

\usepackage[ngerman]{babel} % Deutsche Einstellungen
\usepackage[utf8]{inputenc}	% uft-8 Eingabe
\usepackage[T1]{fontenc} 	% Korrekte Ausgabefonts im Ausgabedokument
\usepackage{csquotes}		% Setzen von Anführungsstrichen
\usepackage{color}

\usepackage{url}

\renewcommand{\labelenumi}{(\roman{enumi})}

% a) Mathematikpakete
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{dsfont}
\usepackage[amsthm,thmmarks]{ntheorem}
\usepackage{amscd}
\usepackage{pictexwd,dcpic} % Für (kommutative u.ä.) Diagramme
\usepackage{amsxtra}% Weitere Extrasymbole
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[varg]{txfonts}
\usepackage{verbatim}
\usepackage{MnSymbol}
\usepackage{xfrac}
\usepackage{faktor}
\usepackage{xparse}
\usepackage{tabularx}

\usepackage{notoccite}


\bibliographystyle{unsrtnat}
\usepackage[numbers,sort&compress]{natbib}

% Lean
%\usepackage[utf8x]{inputenc}
%\usepackage{amssymb}

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.0, 0.1, 0.6}    % red {0.7, 0.1, 0.1}
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green

\usepackage{listings}
\def\lstlanguagefiles{lstftl.tex, lstlean.tex}
\lstset{language=lean}

% b) Lemma, Satz, Theorem usw. 
%\theoremstyle{plain}
\newtheorem{Theorem}{Theorem}[section]
\newtheorem{Satz}[Theorem]{Satz}
\newtheorem{Lemma}[Theorem]{Lemma}
\newtheorem{Korollar}[Theorem]{Korollar}
\newtheorem*{Definition}[Theorem]{}
\newtheorem*{Folgerung}[Theorem]{Folgerung}
\newtheorem*{Behauptung}[Theorem]{Behauptung}
\newtheorem*{Beispiel}{Beispiel}   

\newcommand{\st}{\ \mid\ }
\newcommand{\sd}{\, : \,}
\newcommand{\R}{\mathbb R}
\newcommand{\C}{\mathbb C}
\newcommand{\N}{\mathbb N}
\newcommand{\Z}{\mathbb Z}
\newcommand{\Q}{\mathbb Q}
\newcommand{\E}{\mathbb E}
\newcommand{\Pm}{\mathbb P}
\newcommand{\fF}{\mathfrak{F}}
\newcommand{\df}[1]{\textcolor{blue}{\textbf{#1}}}
\newcommand{\sr}{S(\mathbb{R})}
\newcommand{\ri}{\int_{\R}}
\newcommand{\ra}{\longrightarrow}
\newcommand{\e}{e^{2\pi i\xi x}}
\newcommand{\me}{e^{-2\pi i\xi x}}
\newcommand{\fa}{\;\forall\,}
\newcommand{\Mod}[1]{\ (\mathrm{mod}\ #1)}
\newcommand{\ls}[1]{\lstinline|#1|}

\DeclareDocumentCommand{\fkr}{s m O{0.3} m O{-0.5}}{% \newfaktor[*]{#2}[#3]{#4}[#5] -> #2/#4
	\setbox0=\hbox{\ensuremath{#2}}% Store numerator
	\setbox1=\hbox{\ensuremath{\diagup}}% Store slash /
	\setbox2=\hbox{\ensuremath{#4}}% Store denominator
	\raisebox{#3\ht1}{\usebox0}% Numerator
	\mkern-4mu\ifthenelse{\equal{#1}{\BooleanTrue}}% Slash /
	{\diagup}% regular \faktor slash
	{\rotatebox{-33}{\rule[#5\ht0]{0.3pt}{-#5\ht0+#3\ht0+\ht0}}}% tilted rule as a slash
	\mkern-0mu%
	\raisebox{#5\ht1}{\usebox2}% Denominator
}

\title{Eine Formalisierung des zweiten Satzes von Sylow aus der Gruppentheorie in Naproche im Vergleich zu einer Implementierung in Lean}

\author{Moritz Hartlieb, Jonas Lippert}

\begin{document}
\pagenumbering{gobble}
\maketitle
\newpage
\pagenumbering{arabic}

\section{Einleitung}

In der vorliegenden Arbeit stellen wir die Formalisierung des zweiten Sylow-Satzes in der Sprache Lean vor und vergleichen sie mit einer eigenen Formalisierung in Naproche.

Zu Beginn seien die wichtigsten Definitionen und Resultate der Gruppentheorie skizziert auf Basis des Skripts \enquote{Eine Einführung in die Algebra
	(Skript, WS 19/20, Bonn)} von Prof. Dr. Jan Schröer ~\cite{bibtex.a}.

\subsection{Theoretische Grundlagen}
	Eine \df{Gruppe} ist eine Menge $G$ zusammen mit einer Abbildung $$\circ: G\times G\to G$$ $$(g,h) \mapsto g\circ h = gh$$ sodass gilt:
	\begin{enumerate}
		\item $\circ$ ist assoziativ.
		\item Es gibt ein neutrales Element $e\in G$, sodass $e\circ g=g=g\circ e$ für alle $g\in G$.
		\item Für alle $g\in G$ existiert ein inverses Element $g^{-1}\in G$, sodass $g\circ g^{-1}=g^{-1}\circ g=e$. 
	\end{enumerate}
	
	Eine \df{Untergruppe} H von G, H $\leq$ G, ist eine Teilmenge von G mit
	\begin{enumerate}
		\item $e\in H$.
		\item H ist abgeschlossen bzgl. $\circ$ und Inversenbildung.
	\end{enumerate}
	
	Seien H $\leq$ G gegeben. Für $g \in G$ ist $$gH\coloneqq\{gh\st h\in H\}$$ die \df{Nebenklasse} von H zu g. Es bezeichne $\fkr{G}{H}$ die Klasse der Nebenklassen von H. Weiter sei $$[G : H] \coloneqq |\fkr{G}{H}|$$ der \df{Index} von H zu G.\\\\
	Zwei Untergruppen $H_{1}$ und $H_{2}$ von $G$ sind \df{konjugiert}, falls es ein $g\in G$ gibt
	mit $$H_{1}=gH_{2}g^{-1}\coloneqq \{g\ h\ g^{-1}\st h\in H\}.$$
	
	\begin{Lemma}
		Seien H $\leq$ G gegeben. Für $g_{1}, g_{2}\in G$ gilt:
		\begin{enumerate}
			\item $g_{1}H \cap g_{2}H \neq \emptyset \iff g_{1}H = g_{2}H \iff g_{1}^{-1}g_{2}\in H$
			\item Für alle $g\in G$ is die Abbildung $$H \to gH$$ $$h \mapsto gh$$ bijektiv. Insbesondere gilt im endlichen Fall $|H|=|gH|$.
		\end{enumerate}
	\begin{flushright}
		$\square$
	\end{flushright}
	\end{Lemma}
	
	\begin{Lemma}[Lagrange]
		Seien H $\leq$ G endlich. Dann folgt aus vorherigem Lemma:
		$$|G|=[G : H] \cdot |H|.$$
	\begin{flushright}
		$\square$
	\end{flushright}
	\end{Lemma}
	
	Für eine Gruppe $G$ und eine nichtleere Menge $X$ ist die Abbildung
	$$\phi:G\times X \to X$$
	$$(g,x) \mapsto g.x$$
	eine \df{Gruppenaktion}, falls gilt:
	\begin{enumerate}
		\item $1.x=x$ für alle $x\in X$.
		\item $(gh).x=g.(h.x)$ für alle $g,h\in G$ und $x\in X$.
	\end{enumerate}
	Weiter definieren wir für $x\in X$:
	\begin{enumerate}
		\item den \df{Orbit} $G.x\coloneqq \{g.x\st g\in G\}$ von $x$,
		\item den \df{Stabilisator} $G_{x}\coloneqq \{g\in G\st g.x=x\}$ von $x$,
		\item die Menge der \df{Fixpunkte} $X^{G}\coloneqq\{x\in X\st g.x=x\text{ für alle }g\in G\}$ von $X$.
	\end{enumerate}
	
	\begin{Lemma}
		Sei $G$ eine Gruppe und $X$ nichtleer. Die Funktion
		$$\fkr{G}{G_{x}} \to G.x$$
		$$(g\ G_{x})\mapsto g.x$$
		ist bijektiv.
	\begin{flushright}
		$\square$
	\end{flushright}
	\end{Lemma}
	
	Wie wir in Lemma 1.1 gesehen haben, ist eine Gruppe $G$ disjunkte Vereinigung der Nebenklassen bzgl. einer Untergruppe $H\leq G$. Zusammen mit Lemma 1.3 erhalten wir, dass $X$ disjunkte Vereinigung der Orbits bzgl. einer Gruppenaktion ist und die Kardinalität der Orbits entsprechend Lagrange die Gruppenordnung teilen müssen.
	
	\begin{Lemma}[Bahnenformel]
		Sei $G$ eine endliche Gruppe, sei $X\neq\emptyset$ endlich und seien $x_{1},...,x_{n}$ gegeben, sodass $X$ disjunkte Vereinigung der $G.x_{i}$ ist. Dann gilt 
		$$|X|=\sum_{i=1}^{n}[G:G_{x_i}]=|X^{G}|+\sum\limits_{{1\leq i\leq n} \atop x_{i}\notin X^{G}} [G:G_{x_i}].$$
	\begin{flushright}
		$\square$
	\end{flushright}
	\end{Lemma}
	
	Falls $G$ eine $p$-Gruppe ist, das heißt $|G|=p^{r}$ für eine Primzahl $p$ und ein $r\in\N$, dann folgt:
	\begin{Lemma}
		$$|X| \equiv |X^{G}| \mod p.$$
	\begin{flushright}
		$\square$
	\end{flushright}
	\end{Lemma}
	Für eine Gruppe $G$ mit $|G|=p^{r}m$, wobei $p$ prim und $p\nmid m$, ist die Menge der \df{$p$-Sylowgruppen} definiert durch
	$$\text{Syl}_{p}(G)\coloneqq\{P\ \leq\ G\st \}.$$
	
	Wir können nun den zweiten Satz von Sylow formulieren:
	\begin{Theorem}
		Sei $p$ eine Primzahl und $G$ eine endliche Gruppe mit $|G|=p^{r}*m$, sodass $p\nmid m$. Sei $U \leq G$ eine $p$-Untergruppe, und sei $P \leq G$ eine $p$-Sylowgruppe. Dann gilt:
		\begin{enumerate}
			\item Es gibt ein $g\in G$ mit $$gUg^{-1}\subseteq P.$$
			\item Je zwei $p$-Sylowgruppen sind konjugiert.
		\end{enumerate}
	\begin{proof}
		\begin{enumerate}
			\item Setze $X\coloneqq\fkr{G}{P}$ und betrachte die Gruppenaktion
						$$\phi:U\times X\to X$$
						$$(u,gP)\mapsto ugP.$$
						Nach Lemma 1.5 gilt $$|X|=[G : P]=m\equiv |X^{G}| \mod p.$$
						Da $p\nmid m$, gilt $X^{G}\neq\emptyset$. Es existiert also ein $g\in G$, sodass $ugP=gP$ für alle $u\in U$.
						Folglich ist $g^{-1}Ug\subseteq P$ und damit $U$ konjugiert zu $P$ bzgl. $g^{-1}$.
			\item Dies gilt insbesondere im Falle $U\in \text{Syl}_{p}(G)$.
		\end{enumerate}
	\end{proof}
	\end{Theorem}

\subsection{Vorüberlegungen zur Formalisierung}
Es werden also zunächst Grundbegriffe der Gruppentheorie, endliche Mengen sowie natürliche Zahlen, Primzahlen und Modulo-Rechnung benötigt. Hierzu bieten sich unterschiedliche Herangehensweisen an. 
Es stellt sich heraus, dass Naproche für kleine Theorien gut geeignet ist, deren Grundlagen axiomatisch eingeführt werden, die ihrerseits in einer eigenen Theorie entwickelt werden (können). Die Implementierung in Lean baut hingegen auf bereits formalisierte Grundlagen auf und ist somit Teil einer einzigen großen Theorie der Mathematik. 

Interessant ist die Formalisierung von Nebenklassen. Im Sinne einer kleinen Theorie bietet sich in Naproche eine direkte Konstruktion an: $$Coset\left(g, H, G\right) \coloneqq \left\{\,g *^{G} h \st h << H\,\right\}.$$ Anschließend ist zu zeigen, dass $G$ disjunkte Vereinigung von Nebenklassen bzgl. einer beliebigen Untergruppe $H$ ist.
In Lean wird dagegen bzgl. einer Untergruppe $S$ von $G$ folgende Äquivalenzrelation auf $G$ eingeführt: $$x\sim_{S} y :\Leftrightarrow x^{-1}*y\in S.$$
Lean erlaubt uns, den Quotient $\fkr{G}{\sim_{S}}[-0.2]$ zu betrachten. Hier wird Lemma 1.1 implizit verwendet.
\paragraph*{}
Im Folgenden wird zunächst auf die jeweiligen Formalisierungen im Detail eingegangen. Anschließend sollen Vor- und Nachteile der jeweiligen Sprachen verglichen und diskutiert werden.


\newpage
\section{Formalisierung in Lean}

Die Formalisierung des zweiten Satzes von Sylow in Lean stammt von Chris Hughes\cite{bibtex.c}.
Um mit der aktuellen Version (Stand März 2020) der Leanbibliothek mathlib \cite{bibtex.d} kompatibel zu sein, musste der Quelltext an einigen Stellen angepasst werden. Die modifizierte Version lässt sich unter \url{https://github.com/moritz-hl/sylow2} finden.

	\subsection{Quotienten in Lean}
	Endliche Mengen und Nebenklassen sind in Lean als Quotient formalisiert.
	In der core-Library von Lean sind folgende Konstanten definiert:
	\begin{lstlisting}
		constant quot : Π {α : Sort u}, (α → α → Prop) → Sort u
		constant quot.mk :
		Π {α : Sort u} (r : α → α → Prop), α → quot r
		axiom quot.ind :
		∀ {α : Sort u} {r : α → α → Prop} {β : quot r → Prop},
		(∀ a, β (quot.mk r a)) → ∀ (q : quot r), β q
		axiom quot.sound :
		∀ {α : Type u} {r : α → α → Prop} {a b : α},
		r a b → quot.mk r a =$\hspace*{0cm}$ quot.mk r b
		constant quot.lift :
		Π {α : Sort u} {r : α → α → Prop} {β : Sort u} (f : α → β)),
		(∀ a b, r a b → f a =$\hspace*{0cm}$ f b) → quot r → β
	\end{lstlisting}
	Die Klasse von \lstinline{a} in \lstinline{quot r }wird durch \lstinline{quot.mk r a }erzeugt.
	Das Induktionsaxiom stellt sicher, dass alle Elemente von \lstinline{quot r }von der Form \lstinline{quot.mk r a }sind.
	Die Lifting-Eigenschaft erlaubt es, geeignete Funktionen auf \lstinline{quot r }zu liften.\\
	Ein \lstinline{setoid $\alpha$ }ist ein Typ \lstinline{$\alpha$} zusammen mit einer Äquivalenzrelation:
	\begin{lstlisting}
	class setoid (α : Sort u) :=
	(r : α → α → Prop) (iseqv : equivalence r)
	\end{lstlisting} 
	Der \lstinline{quotient s }auf einem \lstinline{s : setoid $\alpha$ }ist dann der Quotient bzgl. einer Äquivalenzrelation:
	\begin{lstlisting}
	def quotient {α : Sort u} (s : setoid α) :=
	@quot α setoid.r
	\end{lstlisting}
	Die obigen Eigenschaften von \lstinline{quot} werden anschließend auf \lstinline|quotient| übertragen.
	
	\subsection{Endliche Mengen in Lean}
	Endliche Mengen werden auf Basis von Listen definiert. Zunächst erhält man Multimengen als Quotienten, indem Permutationen mit Hilfe der Äquivalenzrelation \lstinline|perm| miteinander identifiziert werden:
	\begin{lstlisting}
	inductive perm : list α → list α → Prop
	| nil   : perm [] []
	| skip  : Π (x : α) {l₁ l₂ : list α},
											perm l₁ l₂ → perm (x::l₁) (x::l₂)
	| swap  : Π (x y : α) (l : list α), perm (y::x::l) (x::y::l)
	| trans : Π {l₁ l₂ l₃ : list α}, perm l₁ l₂ → perm l₂ l₃ → perm l₁ l₃
	\end{lstlisting}
	Unter Verwendung des Beweises \lstinline|perm.eqv|, dass \lstinline|perm| eine Äquivalenzrelation ist, wird eine Instanz von \lstinline|setoid list $\alpha$ |eingeführt, welche dann in der Definition der Multimenge Verwendung findet:
	\begin{lstlisting}
	instance is_setoid (α) : setoid (list α) :=
	setoid.mk (@perm α) (perm.eqv α)
	
	def {u} multiset (α : Type u) : Type u :=
	quotient (list.is_setoid α)
	\end{lstlisting}
	Eine Multimenge wird zur endlichen Menge, wenn sie keine Duplikate beinhaltet:
	\begin{lstlisting}
	structure finset (α : Type*) :=
	(val : multiset α)
	(nodup : nodup val)
	\end{lstlisting}
	Die Definition von \lstinline|nodup| für Multimengen basiert auf \lstinline|nodup| für Listen. 
	\begin{lstlisting}
	def nodup : list α → Prop := pairwise (≠)
	\end{lstlisting}
	Hierbei prüft \lstinline|pairwise|, ob die Relation \lstinline|$\neq$| paarweise gilt.
	\begin{lstlisting}
	variables (R : α → α → Prop)
	inductive pairwise : list α → Prop
	| nil {} : pairwise []
	| cons : ∀ {a : α} {l : list α}, (∀ a' ∈ l, R a a') → pairwise l → pairwise (a::l)
	\end{lstlisting}
	Jetzt wird \lstinline|nodup| für Listen auf Multimengen geliftet. Dazu werden \lstinline|quot.lift$\_$on| folgende Parameter übergeben: der Quotient \lstinline|s|, die zu liftende Funktion \lstinline|nodup| und ein Beweis, dass Permutation keine Duplikate erzeugt: Aus den zwei Listen \lstinline|s t| und dem Beweis \lstinline|p|, dass diese in Relation bzgl. \lstinline|perm| zueinander stehen, erzeugt \lstinline|perm$\_$nodup| die Äquivalenz \lstinline|nodup s $\Leftrightarrow$ nodup t|. Dann wird das Lean-interne Axiom \lstinline|propext| verwendet, nach dem äquivalente Propositionen gleich sind.
	(Die Rechtsklammerung bei der Funktionseinsetzung wird hier durch $\$$ gewährleistet.)
	\begin{lstlisting}
	def nodup (s : multiset α) : Prop :=
	quot.lift_on s nodup (λ s t p, propext $\$$ perm_nodup p)
	
	def quot.lift_on {α : Sort u} {β : Sort v} {r : α → α → Prop} 
	(q : quot r) (f : α → β) (c : ∀ a b, r a b → f a =$\hspace*{0cm}$ f b) : β 
	
	theorem perm_nodup {l₁ l₂ : list α} : l₁ ~ l₂ → 
	(nodup l₁ ↔ nodup l₂)
	\end{lstlisting}
	Der Beweis von \lstinline|perm$\_$nodup| kann in perm.lean nachgelesen werden.
	In der Regel wird nicht \ls{finset} direkt verwendet, sondern die Typenklasse \ls{fintype}, sodass der Typ \ls{$\alpha$} selber endlich ist.
	\begin{lstlisting}
	class fintype (α : Type*) :=
	(elems : finset α)
	(complete : ∀ x : α, x ∈ elems)
	\end{lstlisting}
	
	
	\subsection{MOD in Lean}
	%Um die Formalisierung von \lstinline|a ≡ b [MOD n]| zu illustrieren, wollen wir den %Beweis des folgenden Lemmas nachvollziehen:
	%\begin{lstlisting}
	%lemma mod_zero (a : nat) : a % 0 =$\hspace*{0cm}$ a :=
	%begin
	%rw mod_def,
	%have h : ¬ (0 < 0 ∧ 0 ≤ a),
	%simp [lt_irrefl],
	%simp [if_neg, h]
	%end
	%\end{lstlisting}
	Die Definition von $x\Mod{y}$ auf den natürlichen Zahlen basiert auf der Wohlfundiertheit der $<$-Relation auf $\N$: 
	\begin{lstlisting}
	inductive acc {α : Sort u} (r : α → α → Prop) : α → Prop
	| intro (x : α) (h : ∀ y, r y x → acc y) : acc x
	
	parameters {α : Sort u} {r : α → α → Prop}
	
	local infix `≺`:50    := r
	
	inductive well_founded {α : Sort u} (r : α → α → Prop) : Prop
	| intro (h : ∀ a, acc r a) : well_founded
	
	class has_well_founded (α : Sort u) : Type u :=
	(r : α → α → Prop) (wf : well_founded r)
	\end{lstlisting}
	Ein Element \lstinline|x : $\alpha$| kann nur die Eigenschaft \lstinline|acc| haben, falls ein \enquote{kleinstes} Element bzgl. der Relation \lstinline|R| existiert. Entsprechend wird ein Rekursions- und Induktionsprinzip für wohlfundierte Relationen eingeführt, auf die hier nicht näher eingegangen werden soll. Wichtig ist der Spezialfall, dass sich über wohlfundierte Relationen Funktionen definieren lassen (siehe \lstinline|def fix| weiter unten):
	\begin{lstlisting}
	parameter hwf : well_founded r
	variable {C : α → Sort v}
	variable F : Π x, (Π y, y ≺ x → C y) → C x
	
	def fix_F (x : α) (a : acc r x) : C x :=
	acc.rec_on a (λ x₁ ac₁ ih, F x₁ ih)
	\end{lstlisting}
	Die Konstruktion des Fixpunktes nimmt gemäß \lstinline|acc.rec_on| einen Beweis \lstinline|a| für \lstinline|acc r x| und liefert \lstinline|C x|, falls folgender Sachverhalt gegeben ist:
	\begin{lstlisting}
	($\Pi$ ($x_{1}$ : $\alpha$), ($\forall$ (y : $\alpha$), r y $x_{1}$ $\to$ acc r y) $\to$ 
	($\Pi$ (y : $\alpha$), r y $x_{1}$ $\to$ C y) $\to$ C $x_{1}$)
	\end{lstlisting}
	Durch \lstinline|acc.rec_on| erhalten wir über den Konstruktor \lstinline|intro|:
	\begin{enumerate}
		\item[] \lstinline|$x_{1}$ : $\alpha$|
		\item[] \lstinline|$ac_{1}$ : $\forall$ (y : $\alpha$), r y $x_{1}$ $\to$ acc r y|
		\item[] \lstinline|ih : $\Pi$ (y : $\alpha$), r y $x_{1}$ $\to$ C y|
	\end{enumerate}
	\lstinline|F| liefert das Gewünschte. Wir können die Fixpunkteigenschaft nun auf wohlfundierte Relationen übertragen:
	\begin{lstlisting}
	variables {α : Sort u} {C : α → Sort v} {r : α → α → Prop}
	
	def fix (hwf : well_founded r) (F : Π x, (Π y, r y x → C y) → C x) (x : α) : C x :=
	fix_F F x (apply hwf x)
	\end{lstlisting}
	Ist eine Funktion \lstinline|F| gegeben, welche die Werte \lstinline|C x| für bekannte Werte \lstinline|C y| der \enquote{kleineren} Elemente \lstinline|y $\prec$ x| liefert, so ist nach \lstinline|fix| die Funktion \lstinline|C| für alle \lstinline|x : $\alpha$| definiert. 
	Für \lstinline|F| setzen wir
	\begin{lstlisting}
	private def mod.F (x : nat) (f : Π x₁, x₁ < x → nat → nat) (y : nat) : nat :=
	if h : 0 < y ∧ y ≤ x then f (x - y) (div_rec_lemma h) y else x
	\end{lstlisting}
	und damit \lstinline|C| auf \lstinline|$\N\to\N\to\N$|. Hier wurde folgendes Lemma verwendet:
	\begin{lstlisting}
	div_rec_lemma {x y : nat} : 0 <	 y ∧ y ≤ x → x - y < 	x.
	\end{lstlisting}
	Weiter können wir \lstinline|mod| und damit eine Instanz der Typenklasse \lstinline|class has$\_$mod |definieren, die bereits in \lstinline|core.lean| vordefiniert ist. Sie besitzt einzig den Konstruktor \lstinline|has$\_$mod.mod : $\N\to\N\to\N$|.
	\begin{lstlisting}
	protected def mod := fix lt_wf mod.F
	
	instance : has_mod nat :=
	⟨nat.mod⟩
	\end{lstlisting}
	Die Infixnotation für \lstinline|has$\_$mod.mod n m |ist \lstinline|n % m|.
	Schließlich wird \lstinline|a ≡ b [MOD n]| definiert:
	\begin{lstlisting}
	def modeq (n a b : ℕ) := a % n =$\hspace*{0cm}$ b % n
	
	notation a ` ≡ `:50 b ` [MOD `:50 n `]`:0 := modeq n a b
	\end{lstlisting}




	\subsection{Gruppen in Lean}
	Gruppen werden sukzessive durch Erweiterungen von \lstinline|type calsses| definiert:
	\begin{lstlisting}
	class has_mul (α : Type u) := (mul : α → α → α)
	
	infix * := has_mul.mul
	
	class semigroup (α : Type u) extends has_mul α :=
	(mul_assoc : ∀ a b c : α, a * b * c = a * (b * c))
	
	class monoid (α : Type u) extends semigroup α, has_one α :=
	(one_mul : ∀ a : α, 1 * a = a) (mul_one : ∀ a : α, a * 1 = a)
	
	class group (α : Type u) extends monoid α, has_inv α :=
	(mul_left_inv : ∀ a : α, a⁻¹ * a = 1)
	\end{lstlisting}
	Entsprechendes gilt für Untergruppen
	\begin{lstlisting}
	variables {α : Type*} [monoid α] {s : set α}
	
	class is_submonoid (s : set α) : Prop :=
	(one_mem : (1:α) ∈ s)
	(mul_mem {a b} : a ∈ s → b ∈ s → a * b ∈ s)
	
	class is_subgroup (s : set α) extends is_submonoid s : Prop :=
	(inv_mem {a} : a ∈ s → a⁻¹ ∈ s)
	\end{lstlisting}
	und Gruppenaktionen:
	\begin{lstlisting}
	class has_scalar (α : Type u) (γ : Type v) := 
	(smul : α → γ → γ)

	infixr ` • `:73 := has_scalar.smul
	
	class mul_action (α : Type u) (β : Type v) [monoid α] extends has_scalar α β :=
	(one_smul : ∀ b : β, (1 : α) • b = b)
	(mul_smul : ∀ (x y : α) (b : β), (x * y) • b = x • y • b)
	\end{lstlisting}
	Es folgen die üblichen Definitionen bzgl. Gruppenaktionen.
	\begin{lstlisting}
	variables (α) [monoid α] [mul_action α β]
	
	def orbit (b : β) := set.range (λ x : α, x • b)
	
	variables (α) (β)
	
	def stabilizer (b : β) : set α :=
	{x : α | x • b = b}
	
	def fixed_points : set β := {b : β | ∀ x, x ∈ stabilizer α b}
	\end{lstlisting}
	Nebenklassen werden als Quotient bzgl. der Relation \lstinline|left_rel| definiert:
	\begin{lstlisting}
	def left_rel [group α] (s : set α) [is_subgroup s] : setoid α :=
	⟨λ x y, x⁻¹ * y ∈ s,
	assume x, by simp [is_submonoid.one_mem],
	assume x y hxy,
	have (x⁻¹ * y)⁻¹ ∈ s, from is_subgroup.inv_mem hxy,
	by simpa using this,
	assume x y z hxy hyz,
	have x⁻¹ * y * (y⁻¹ * z) ∈ s, from is_submonoid.mul_mem hxy hyz,
	by simpa [mul_assoc] using this⟩
	
	def left_cosets [group α] (s : set α) [is_subgroup s] : Type* := quotient (left_rel s)
	\end{lstlisting}
	Für eine Untergruppe \ls{H} von \ls{G} ist dann \ls{left_rel H} ein \ls{setoid G} mit entsprechender Relation und dem zugehörigen Beweis, dass es sich um eine Äquivalenzrelation handelt.
	Mithilfe dieser Definition wird eine Instanz von \ls{fintype} bzgl. \lstinline|left_costes H| erstellt:
	\begin{lstlisting}
	noncomputable instance [fintype G] (H : set G) [is_subgroup H] :  fintype (left_cosets H) := 
	quotient.fintype (left_rel H)
	\end{lstlisting}
	Der Grund dafür, dass die Instanz als \ls{noncomputable} markiert werden muss, ist die Verwendung von \ls{decidable.eq} in \ls{quotient.fintype}. Das geht auf den Umstand zurück, dass das Bild einer Funktion auf einem endlichen Typ wieder ein endlicher Typ \ls{$\beta$} ist. Hierbei wird das Bild zunächst als Multimenge betrachtet. Anschließend werden eventuelle Duplikate durch den Operator \ls{to_finset} entfernt, was die Entscheidbarkeit der Gleichheitsrelation auf $\beta$ voraussetzt.
	Um den 2. Sylowsatz in Lean zu formulieren, fehlen noch die Definitionen des \ls{conjugate_set} und der $p$-Sylowgruppen:
	\begin{lstlisting}
	def conjugate_set (x : G) (H : set G) : set G :=
	(λ n, x⁻¹ * n * x) ⁻¹' H
	
	class is_sylow [fintype G] (H : set G) {p : ℕ} (hp : prime p) extends is_subgroup H : Prop := 
	(card_eq : card H = p ^ dlogn p (card G))
	
	lemma sylow_2 [fintype G] {p : ℕ} (hp : nat.prime p)
	(H K : set G) [is_sylow H hp] [is_sylow K hp] :
	∃ g : G, H = conjugate_set g K 
	\end{lstlisting}
	\ls{dlogn p (card G)} ist die Vielfachheit von \ls{p} in \ls{card G}.\\\\
	\ls{#print axioms sylow.sylow_2} zeigt, dass \ls{propext}, \ls{quot.sound} und \ls{calssical.choice} verwendet wird.\\\\                                        
	\ls{quot.sound} wird benötigt, um zu beweisen, dass das kanonische Operieren einer Untergruppe \ls{H} auf den Nebenklassen einer Untergruppe \ls{K} eine Gruppenaktion ist:
	\begin{lstlisting}
	def mul_left_cosets (L₁ L₂ : set G) [is_subgroup L₂] [is_subgroup L₁]
	(x : L₂) (y : left_cosets L₁) : left_cosets L₁ :=
	quotient.lift_on y (λ y, $\lsem$(x : G) * y$\rsem$) 
	(λ a b (hab : _ ∈ L₁), quotient.sound 
	(show _ ∈ L₁, by rwa [mul_inv_rev, ← mul_assoc, mul_assoc (a⁻¹), inv_mul_self, mul_one]))
	\end{lstlisting}
	Dafür soll die Funktion \ls{(λ y, $\lsem$(x : G) * y$\rsem$)} auf Nebenklassen geliftet werden. Für zwei Elemente \ls{a} und \ls{b}, die bzgl. \ls{left_rel} äquivalent sind, ist also zu zeigen, dass
	\begin{lstlisting}
	$\lsem$(x : G) * a$\rsem$ = $\lsem$(x : G) * b$\rsem$.
	\end{lstlisting}
	Mit \ls{quot_sound} genügt dann ein Beweis dafür, dass die erzeugenden Elemente äquivalent sind. Die nötigen Umformungen erledigt \ls{simp}.
	
	Im Beweis von Sylow 2 werden zunächst die vorangegangenen Resultate verwendet, um herzuleiten, dass die Anzahl der Fixpunkte bzgl. obiger Aktion ungleich Null ist. An dieser Stelle liefert \ls{classical.choice} einen solchen Fixpunkt, ohne den die Konstruktion eines geeigneten \ls{conjugate_set} nicht möglich wäre.


	\subsection{Sylow 2 in Lean}
	Wir wollen nun auf einige Details im Beweis des Satzes eingehen. Die verwendeten Lemmata, die für das sukzessive Umformen via \ls{rw} oder \ls{simp} genutzt werden, sind dabei weder mathematisch noch hinsichtlich des Formalisierungsprozesses besonders interessant. Es werden zahlreiche technische Lemma über natürliche Zahlen, Kardinalitäten, Funktionen, etc. zusammengetragen, deren Beweise für den Menschen trivial und in Lean im Nachhinein teilweise nur sehr schwer verständlich sind. Es ist prinzipiell klar, dass es auf Basis der konstruierten Begriffe und Strukturen möglich ist, entsprechende Beweise für Lean verständlich zu formulieren und es genügt in der Regel zu wissen, dass sie existieren.
	
	Die ersten drei Hilfslemma liefern uns den gewünschten Fixpunkt.
	\begin{lstlisting}
	lemma sylow_2 [fintype G] {p : ℕ} (hp : nat.prime p)
	(H K : set G) [is_sylow H hp] [is_sylow K hp] :
	∃ g : G, H = conjugate_set g K :=
	
	have hs : card (left_cosets K) = card G / (p ^ dlogn p (card G)) := 
	(nat.mul_right_inj (pos_pow_of_pos (dlogn p (card G)) hp.pos)).1
	$\$$ by rw [ ← card_sylow K hp, ← card_eq_card_cosets_mul_card_subgroup, card_sylow K hp, 
	nat.div_mul_cancel (dlogn_dvd _ hp.1)],
	
	have hmodeq : card G / (p ^ dlogn p (card G)) ≡ card (fixed_points H (left_cosets K)) [MOD p] := 
	eq.subst hs (mul_action.card_modeq_card_fixed_points hp (card_sylow H hp)),
	
	have hfixed : 0 < card (fixed_points H (left_cosets K)) := 
	nat.pos_of_ne_zero 
	(λ h, (not_dvd_div_dlogn (fintype.card_pos_iff.2 ⟨(1 : G)⟩) hp.1) 
	(by rwa [h, nat.modeq.modeq_zero_iff] at hmodeq)),
	\end{lstlisting}
	Zunächst wird in \lstinline|hs| die Kardinalität der Klasse der Nebenklassen auf Basis der Definition von Sylow-Gruppen umgeformt. Hierbei wird das Lemma von Lagrange unter dem Namen \ls{card_eq_card_cosets_mul_card_subgroup} benutzt.
	
	In \ls{hmodeq} kommt die Lean-Version von Lemma (??) zur Anwendung: 
	\begin{lstlisting}
	lemma card_modeq_card_fixed_points [fintype α] [fintype G] 
	[fintype (fixed_points G α)]
	{p n : ℕ} (hp : nat.prime p) (h : card G = p ^ n) : 
	card α ≡ card (fixed_points G α) [MOD p]
	\end{lstlisting}
	Durch Substitution wird das allgemeine Resultat auf den Spezialfall übertragen.
	
	Mit Hilfe von \ls{hmodeq} lässt sich schließlich \ls{hfixed} zeigen, dass nämlich die Kardinalität der Fixpunkte größer Null ist. Nach \ls{nat.pos_of_ne_zero} genügt es zu zeigen, dass die Kardinalität der Fixpunkte ungleich Null ist. Es wird also ein Beweis von \ls{false} gefordert unter Annahme \ls{h}, die Kardinalität sei gleich Null. Der Widerspruch wird erzeugt, in dem erst 
	\begin{lstlisting}	
	lemma not_dvd_div_dlogn {p a : ℕ} (ha : a > 0) (hp : p > 1) : 
	¬p ∣ a / (p ^ dlogn p a)
	\end{lstlisting}
	auf \ls{a = card G} angewendet wird. Dass \ls{p} aber ein Teiler der rechten Seite sein muss, folgt aus der Annahme \ls{h} zusammen mit
	\begin{lstlisting}
	modeq_zero_iff : b ≡ 0 [MOD n] ↔ n ∣ b,
	\end{lstlisting}
	wobei \ls{b = card G / (p ^ dlogn p a)}.
	
	Um aus dem abstrakten Kardinalitäts-Argument einen konkreten Fixpunkt zu gewinnen, wird das Axiom \ls{classical.choice} in Form des Lemmas \ls{fintype.card_pos_iff} verwendet:
	\begin{lstlisting}
	let ⟨⟨x, hx⟩⟩ := fintype.card_pos_iff.1 hfixed in
	
	begin
	
	revert hx
	\end{lstlisting}
	Die Taktik \ls{revert} generalisiert den Beweis \ls{hx}, dass \ls{x} ein Fixpunkt ist, sodass nun folgendes zu beweisen ist:
	\begin{lstlisting}
	x ∈ fixed_points H (left_cosets K) → 
	(∃ (g : G), H = conjugate_set g K)
	\end{lstlisting}
	Der Grund dafür ist der, dass wir für die weitere Argumentation einen Vertreter \ls{g : G} für die Äquivalenzklasse \ls{x} benötigen. Dies wird möglich durch das Axiom \ls{quot.ind} in Form von \ls{quotient.induction_on}, nachdem es genügt, das Ziel für einen beliebigen Vertreter zu zeigen:
	\begin{lstlisting}
	refine quotient.induction_on x
	(λ g hg, ⟨g, set.eq_of_card_eq_of_subset _ _⟩)
	\end{lstlisting}
	Für ein Element \ls{g : G} und unter der Annahme \ls{hg}, dass \ls{$\lsem$g$\rsem$} ein Fixpunkt ist, bleibt nun die ursprünglich Aussage \ls{$\exists$(g : G), H = conjugate_set g K} zu zeigen.
	Dem anonymen Konstruktor wurde zur Konstruktion der Existenzaussage das Element \ls{g} und folgendes Lemma übergeben:
	\begin{lstlisting}
	lemma eq_of_card_eq_of_subset {s t : set α} [fintype s] [fintype t]
	(hcard : card s = card t) (hsub : s ⊆ t) : s = t
	\end{lstlisting}
	Durch die Verwendung der Taktik \ls{refine} und der zwei Unterstriche anstelle der Beweise \ls{hcard} und \ls{hsub}, werden diese Bedingungen als neue Ziele innerhalb des Taktik-Blocks erstellt, wobei das ursprüngliche Ziel als bewiesen gilt. Die beiden Beweise seien hier der Vollständigkeit halber aufgeführt, auch wenn die technischen Details nicht weiter interessant sind:
	\begin{lstlisting}
	{ 
	rw [conjugate_set_eq_image, set.card_image_of_injective _ conj_inj_left,
	card_sylow K hp, card_sylow H hp] },
	{
	assume y hy,
	have : (y⁻¹ * g)⁻¹ * g ∈ K := 
	quotient.exact ((mem_fixed_points' (left_cosets K)).1 hg $\lsem$y⁻¹ * g$\rsem$ 
	⟨⟨y⁻¹, inv_mem hy⟩, rfl⟩),
	simp [conjugate_set_eq_preimage], 
	simp only [*, mul_assoc, mul_inv_rev] at *,
	simp [*, inv_inv] at *}
	end
	\end{lstlisting}
\newpage
\section{Formalisierung in Naproche}

\lstset{language=ftl, basicstyle = \fontsize{10}{13}\selectfont\ttfamily}

\subsection{Struktur }
Die Formalisierung in Naproche teilt sich in 8 Dateien auf:

\medskip

\begin{tabularx}{\textwidth}{p{0.25\textwidth}|X|r}
	Name & Inhalt & Abschnitt\\
	\hline
	01basicgrouptheory.ftl 		& Gruppentheorie		& 3.2\\
	\hline
	02numbers.ftl		& Zahlen		& 3.6\\
	\hline
	03cards.ftl			& Kardinalitäten		& 3.9\\
	\hline
	04lagrange.ftl 		& Satz von Lagrange		& 3.10\\
	\hline
	05staborb.ftl		& Gruppenaktionen		& 3.11\\
	\hline
	06fixedpointsmodp.ftl		& Fixpunkte		& 3.13\\
	\hline
	07grpaction.ftl 	& SylowGruppenaktion		& 3.14\\
	\hline
	08sylow2.ftl & Der Satz von Sylow  & 3.15 \\

\end{tabularx}

\medskip

In jeder Datei werden zu Beginn jeweils die Aussagen und Definitionen der vorangegangen Dateien eingebunden. Hierfür wurden Hilfsdateien \verb!xxExport.ftl! erstellt, in denen zu jeder Datei die daran enthalten Definitionen und Theoreme in Form von Axiomen ohne Beweise festgehalten wurden.
Grundsätzlich wäre es möglich diese Dateien über den Befehl \verb![read dateiname.ftl]! einzulesen, da dieser Befehl jedoch in der jetzigen Version von Naproche nicht auf allen Betriebssystemen gleichermaßen funktioniert, haben wir die Dateien manuell kopiert und dies durch Kommentare im Quelltext vermerkt.

Die Formalisierung ließ sich auf einem MacBook Pro (16 GB RAM, Intel i7 2,7 GhZ) von 2018 innerhalb der Isabelle-Naproche Umgebung in rund 5 Minuten verifizieren. Fügt man jedoch alle Dateien aneinander, ohne die Theoreme jeweils durch Axiome zu ersetzen, dann ist Naproche nicht mehr in der Lage, den Beweis vollständig zu verifizieren.

Der Dateien finden sich unter \url{https://github.com/moritz-hl/sylowftl}.

\subsection{Grundlegende Definitionen}

Zunächst führen wir einige grundlegenden Definitionen ein.
Interessant ist hier insbesondere der Begriff der \verb!disjunct collection! den wir einführen um später über disjunkte Vereinigung ''sprechen'' zu können.

\begin{lstlisting}
Let M, N denote sets.
Let x << M stand for x is an element of M.

Definition.
Prod(M,N) = { (x,y) | x << M and y << N }.

Definition.
A subset of M is a set N such that every element of N is an element of M.

Definition.
Let M be a set.
M is empty iff there is no element x of M such that x = x.

Definition.
Let M be a set such that for all elements N of M N is a set.
\-/ M = {x | There is an element N of M such that x is an element of N}.

Definition.
Let N1, N2 be sets.
N1 \-/ N2 = {x | x is an element of N1 or x is  an element of N2}.

Definition.
Let N1 be a set.
Let N2 be a subset of N1.
N1 \\ N2 = {x | x is an element of N1 and (x is not an element of N2)}.

Definition.
Let N1, N2 be a sets.
N1 and N2 are disjunct iff there is no element x of N1 such that x is an element of N2.

Definition.
A disjunct collection is a set M such that 
(for all elements N of M N is a set) and for all elements N1, N2 of M (N1 = N2 or ( N1 and N2 are disjunct)).

Definition.
Let f be a function. Let M,N be sets. f is from M to N iff Dom(f) = M and for every element x of M f[x] is an element of N.

Definition.
Let f be a function. Range(f) = {f[x] | x << Dom(f)}.

Definition.
Let f be a function. f is injective iff for all elements x,y of Dom(f) we have (x!=y => f[x] != f[y]).

Definition.
Let f be a function. f is surjective onto M iff 
(f is from Dom(f) to M 
and for every y << M there is an element x of Dom(f) such that f[x]=y).
\end{lstlisting}

\subsection{Einführung des Gruppenbegriffs}

Der Gruppenbegriff wird abstrakt als \verb!Notion! eingeführt.
Für diese \verb!Notion! werden die Existenz einer Trägermenge \verb!El(G)!, die Existenz der Eins, Inversen und Verknüpfung sowie deren Eigenschaften axiomatisch gefordert.
Die Verknüpfung \verb!a *^{G} b! muss hier explizit durch \verb!G! gekennzeichnet werden.

\begin{lstlisting}

[synonym group/-s]
[synonym subgroup/-s]

Signature.
A group is a notion.

Let G denote a group.

Signature.
El(G) is a  set.

Signature.
One(G) is an object.

Axiom.
One(G) << El(G).

Signature.
Let a, b be elements of El(G).
a *^{G} b is an element of El(G).

Signature.
Let a be an element of El(G).
Inv(a, G) is an element of El(G).

Axiom Assoc.
Let x, y, z be elements of El(G). x *^{G} ( y *^{G} z) = (x *^{G} y) *^{G} z. 

Axiom InvOne.
Let x be an element of El(G). x *^{G} Inv(x, G) = One(G) = Inv(x, G) *^{G} x.

Axiom MulOne.
Let x be an element of El(G). x *^{G} One(G) = x =  One(G) *^{G} x.

Lemma InvUniq.
Let x, y be elements of El(G).
If x *^{G} y = One(G) then y = Inv(x, G).

Lemma OneUniq.
Let x, y be elements of El(G).
If x *^{G} y = x then y = One(G).

\end{lstlisting}

\subsection{Untergruppen}

Untergruppen werden als Teilmengen von \verb!El(G)! eingeführt.
Im Beweis von Sylow wird genutzt, dass Untergruppen selbst wieder eine Gruppenstruktur annehmen. Da wir den Begriff der Gruppe abstrakt eingeführt haben, ist es hier nicht möglich, zu beweisen, dass \verb!Gr(U, G)! eine Gruppe ist, weswegen dies hier auch als Axiom gefordert wird.


\begin{lstlisting}

Definition.
A subgroup of G is set H such that
(H is a subset of El(G))
and (One(G) << H)
and (for every x << H Inv(x, G) << H)
and (for all elements x, y of H x *^{G} y << H).

Definition.
Let U be a subgroup of G.
Gr(U, G) is a group H such that
(El(H) = U)
and (One(H) = One(G))
and (for every x << U Inv(x, H) = Inv(x, G))
and (for all elements x, y of U x *^{Gr(U, G)} y = x *^{G} y).

Lemma.
Let G be a group.
Let H be a subset of El(G).
Assume ((There is a x << H such that x = x) and (for all elements  y, z of H  z *^{G} Inv(y, G) << H)).
H is a subgroup of G.
Proof.
  One(G) << H.
    Proof.
      Take x << H.
      Then One(G) = x *^{G} Inv(x, G).
      Thus One(G) << H.
    end.

  For every x << H Inv(x, G) << H.
    Proof.
      Let x be an element of H.
      Then Inv(x, G) = One(G) *^{G} Inv(x, G).
      Thus Inv(x, G) << H.
    end.

  For all elements x, y of H x *^{G} y << H.
  Proof.
    Let x, y be elements of H.
    Then Inv(x, G) << H.
    x *^{G} y = x *^{G}  Inv(Inv(y, G), G).
    Hence x *^{G} y << H.
    end.
Qed.

\end{lstlisting}

\subsection{Nebenklassen}

Wir führen Nebenklassen im Gegensatz zum Ansatz der Formalisierung in Lean nicht über Qoutienten ein, sondern über die mengenbasierte Definition.
Das in der Einführung genannte Lemma begründet, dass diese Ansätze das gleiche metatheoretische Objekt formalisieren.

\begin{lstlisting}

Definition.
Let g be an element of El(G).
Let H be a subgroup of G.
Coset(g, H, G) = {g *^{G} h | h << H}.

Lemma.
Let H be a subgroup of G.
Let g1, g2 be elements of El(G).
Assume Coset(g1, H, G) and Coset(g2, H, G) are not disjunct.
Inv(g2, G) *^{G} g1 << H.
Proof.
  Take y << El(G) such that (y << Coset(g1, H, G) and y << Coset(g2, H, G)).
  Take b << H such that y = g1 *^{G} b.
  Take c << H such that y = g2 *^{G} c.

  We have g1 = y *^{G} Inv(b, G).
          g2 = y *^{G} Inv(c, G).
          Inv(g2, G) = c *^{G} Inv(y, G).
          Inv(y, G) *^{G} g1 = Inv(b, G).

  Therefore Inv(g2, G) *^{G}  g1 = c *^{G} (Inv(b, G)).
qed.


Lemma.
Let H be a subgroup of G.
Let g1, g2 be elements of El(G).
If Inv(g2, G) *^{G} g1 << H
Then Coset(g1, H, G) = Coset(g2, H, G).
Proof.
Assume Inv(g2, G) *^{G} g1 << H.

Every element of Coset(g1, H, G) is an element of Coset(g2, H, G).
Proof.
  Let y be an element of Coset(g1, H, G).
  Take a << H such that y = g1 *^{G} a.
  (Inv(g2, G) *^{G}  g1) *^{G}  a << H.
  Then y = g1 *^{G}  a = g2 *^{G} ((Inv(g2, G) *^{G}  g1) *^{G}  a).
end.

Every element of Coset(g2, H, G) is an element of  Coset(g1, H, G).
Proof.
  Let y be an element of Coset(g2, H, G).
  Take a << H such that y = g2 *^{G} a.
  (Inv(g2, G) *^{G}  g1) *^{G}  a << H.
  Then y = g2 *^{G} a =g1 *^{G} ((Inv(g1, G)*^{G} g2)*^{G} a).
end.

Therefore Coset(g1, H, G) = Coset(g2, H, G).
Qed.

Lemma CosEq.
Let H be a subgroup of G.
Let g1, g2 be elements of El(G).
If Coset(g1, H, G) and  Coset(g2, H, G) are not disjunct
then Coset(g1, H, G) = Coset(g2, H, G).

Lemma.
Let H be a subgroup of G.
Let g1, g2 be elements of El(G).
Inv(g2, G)*^{G} g1 << H iff Coset(g1, H, G) = Coset(g2, H, G).

Definition.
Let H be a subgroup of G.
Cosets(H, G) = {Coset(g, H, G) | g << El(G)}.

[synonym coset/-s]
Let a coset of H in G denote an element of Cosets(H, G).

Lemma.
Let U be a subgroup of G.
El(G) = \-/ Cosets(U, G).
Proof.
Let us show that every element of El(G) is an element of \-/ Cosets(U, G).
  Let g be an element of El(G).
  g is an element of Coset(g, U, G).
end.

Let us show that every element of \-/ Cosets(U, G) is an element of El(G).
  Let h be an element of \-/ Cosets(U, G).
  Take an element k of El(G) such that h is an element of Coset(k, U, G).
  Coset(k, U, G) is a subset of El(G).
  Hence h is an element of El(G).
end.

Therefore El(G) = \-/ Cosets(U, G).
Qed.

Lemma.
Let G be a group.
Let U be a subgroup of G.
Cosets(U, G) is a disjunct collection.
Proof.
Let us show that for every elements N1, N2 of Cosets(U, G) N1 = N2 or (N1 and N2 are disjunct).
  Let N1, N2 be cosets of U in G.
  Take elements g1, g2 of El(G) such that N1 = Coset(g1, U, G) and N2 = Coset(g2, U, G).
  If N1 and N2 are not disjunct then N1 = N2 (by CosEq).
  Therefore the thesis.
end.
Qed.

Lemma.
Let G be a group.
Let U be a subgroup of G.
U is a coset of U in G.
Proof.
  We have U = Coset(One(G), U, G).
  Therefore the thesis.
Qed.

Definition.
Let g be an element of El(G).
Let U be a subgroup of G.
Conjugate(g, U, G) = {(g *^{G} (u *^{G} Inv(g, G)))| u is an element of U}.

Definition.
Let U, V be subgroups of G.
U and V are conjugates in G iff there is an element g of El(G) such that U = Conjugate(g, V, G).

\end{lstlisting}

\subsection{Zahlen}

Da wir uns mit endlichen Gruppen, also insbesondere mit Kardinalitäten beschäftigen, führen wir nun ganze Zahlen axiomatisch ein. 
Übernommen : Interessant, während MulZero, MulMinOne in der Beispieldatei nicht weiter bewiesen werden mussten, musste auf.

Ein herkömmlicher mathematischer Text über die Sylowsätze behandelt auch nicht elementare Zahlentheorie sondern nimmt eine gewisse Vorkenntnis des Lesers an.

In diesem Sinne führen wir auch die Zahlen abstrakt ein und fordern wohlbekannte Eigenschaften axiomatisch.


\begin{lstlisting}
	[synonym integer/-s]
	[synonym number/-s]
	
	Signature Integers. An integer is a notion.
	
	Signature Naturals. A natural number is an integer.
	
	Let a,b,c,d,e,n,m stand for integers.
	
	Signature NatZero.  0 is a natural number.
	Signature NatOne.   1 is a natural number.
	
	Signature IntNeg.   -a is an integer.
	Signature IntPlus.  a + b is an integer.
	Signature IntMult.  a * b is an integer.
	
	Signature NatPot. Let b be a natural number.  a ^ b is an integer.
	
	Axiom NatPlus. If a and b are natural numbers then a + b is a natural number.
	Axiom NatMult. If a and b are natural numbers then a * b is a natural number.
	
	Signature NatLT. a < b is an atom.
	
	Let a is smaller than b stand for a < b.
	
	Axiom TriCh.
	a = b \/ a < b \/ b < a.
	
	Axiom.
	a < b iff a != b.
	
	Let a - b stand for a + (-b).
	
	Axiom NatSub.
	If a < b then b - a is natural number.
	
	Axiom AddAsso.      a + (b + c) = (a + b) + c.
	Axiom AddComm.      a + b = b + a.
	Axiom AddZero.      a + 0 = a = 0 + a.
	Axiom AddNeg.       a - a = 0 = -a + a.
	
	Axiom MulAsso.      a * (b * c) = (a * b) * c.
	Axiom MulComm.      a * b = b * a.
	Axiom MulOne.       a * 1 = a = 1 * a.
	
	Axiom Distrib.      a * (b + c) = (a*b) + (a*c) and
						(a + b) * c = (a*c) + (b*c).
	
	Axiom ZeroDiv.      a != 0 /\ b != 0 => a * b != 0.
	
	Axiom PotInj.   Let p be an integer. Let n,m be natural numbers. (p ^ n = p ^  m) => n = m.
	Axiom PotAdd. Let p be an integer. Let n, m be natural numbers. p ^ (n + m) = (p ^ n) * (p  ^ m).
	Axiom PotNotZero. Let p be an integer. Let k be a natural number. p ^ k  != 0.
	
	
	Lemma MulZero.      a * 0 = 0 = 0 * a.
	Proof.
	  a*(1+(-1)) = (a*1)+(a*(-1))=0.
	Qed.
	
	Lemma MulMinOne.    (-1) * a = -a = a * -1.
	Proof.
	  a+(-1 * a)= (1*a)+(-1 * a) = 0.
	Qed.
	
	Lemma IntCanc.
	c != 0 /\ a * c = b * c => a = b.
	Proof.
	  Assume c != 0 /\ a * c = b * c.
	  
	  (1) (a+ (-b))*c = (a * c) + ((-b) * c) = 0.
	  
	  Therefore a - b = 0 (by ZeroDiv, 1).
	Qed.
	
	Let a is nonzero stand for a != 0.
	Let p,q stand for nonzero integers.
	
	[synonym divisor/-s] [synonym divide/-s]
	
	Definition Divisor. A divisor of b is a nonzero integer a
						such that for some n (a * n = b).
	
	Let a divides b stand for a is a divisor of b.
	Let a | b stand for a is a divisor of b.
	
	Lemma DivPlus.
	q | a /\ q | b =>  q | (a + b).
	
	Definition EquMod.  a = b (mod q) iff q | a-b.
	
	Definition NeqMod.  a != b (mod q) iff not (a = b (mod q)).
	
	Lemma EquModRef.    a = a (mod q).
	
	[ontored on]
	Lemma EquModSym.    a = b (mod q) => b = a (mod q).
	Proof.
		Assume that a = b (mod q).
		(1) Take n such that q * n = a - b.
		q * -n .= (-1) * (q * n) (by MulMinOne, MulAsso,MulComm,MulBubble)
					   .= (-1) * (a - b) (by 1).
		Therefore q | b-a.
	qed.
	
	Lemma EquModTrn.    a = b (mod q) /\ b = c (mod q) => a = c (mod q).
	Proof.
		Assume that a = b (mod q) /\ b = c (mod q).
		Take n such that q * n = a - b.
		Take m such that q * m = b - c.
		We have q * (n + m) = a - c.
	qed.
	
	Lemma EquModMul. a = b (mod p * q) => a = b (mod p) /\ a = b (mod q).
	Proof.
		Assume that a = b (mod p * q).
		Take m such that (p * q) * m = a - b.
		We have p * (q * m) = a - b = q * (p * m).
	qed.
	[/ontored]
	
\end{lstlisting}

\subsection{Primzahlen}

Primzahlen.

Wichtigste Eigenschaft, das erste Axiom.

\begin{lstlisting}

	Signature Prime.    a is prime is an atom.
	
	Let a prime stand for a prime nonzero integer.
	
	Axiom.
	Let n be a natural number.
	Let p be a prime.
	Let k be a natural number.
	If k | p^n then k = 1 or p | k.
	
	Axiom.
	Let k be a natural number.
	k != 0 => p | p^k.
	

\end{lstlisting}

\subsection{Ein Lemma über Potenzen}

Das folgende Lemma wird eine zentrale Rolle im Beweis des zweiten Teiles des Satzes einnehmen.
Wir liefern hier einen Beweis, der sich durch ein Symmetrieargument vereinfachen ließe. 

\begin{lstlisting}
	Lemma DLogN.
	Let p be a prime.
	Let a, b be natural numbers.
	If n = (p^a)*c /\ n = (p^b)*d and p does not divide c and p does not divide d then a = b.
	Proof.
	Assume n = (p^a)*c and n = (p^b)*d and p does not divide c and p does not divide d.
	
	b is not smaller than a.
	Proof by Contradiction.
	  Assume b < a.
	  We have p^a = (p^(a-b))*(p^b).
	
	  (1) (p^a)*c = (p^b)*d.
	  (2) ((p^(a-b))*(p^b))*c = (p^b)*d.
	  (3) ((p^b)*(p^(a-b)))*c = (p^b)*d (by 1, MulComm).
	  (4) (p^b)*((p^(a-b))*c) = (p^b)*d (by 3, MulAsso).
	  (5) ((p^(a-b))*c)*(p^b) = d*(p^b) (by 4, MulComm).
	  
	  (6)((p^(a-b))*c) = d (by 5, IntCanc, PotNotZero).
	  
	  a-b != 0.
	
	  p is a divisor of p^(a-b).
	  p is a divisor of ((p^(a-b))*c).
	
	  p does divide d.
	  p does not divide  d.
	
	  Contradiction.
	end.
	
	a is not smaller than b.
	Proof by Contradiction.
	  Assume a < b.
	  We have p^b = (p^(b-a))*(p^a).
	
	  (1) (p^b)*d = (p^a)*c.
	  (2) ((p^(b-a))*(p^a))*d = (p^a)*c.
	  (3) ((p^a)*(p^(b-a)))*d = (p^a)*c (by 1, MulComm).
	  (4) (p^a)*((p^(b-a))*d) = (p^a)*c (by 3, MulAsso).
	  (5) ((p^(b-a))*d)*(p^a) = c*(p^a) (by 4, MulComm).
	  
	  (6)((p^(b-a))*d) = c (by 5, IntCanc, PotNotZero).
	  
	  b-a != 0.
	
	  p is a divisor of p^(b-a).
	  p is a divisor of ((p^(b-a))*d).
	
	  p does divide c.
	  p does not divide  c.
	
	  Contradiction.
	end.
	
	Therefore the thesis.
	qed.
\end{lstlisting}


\subsection{Endliche Mengen}

Endliche Mengen führen wir als abstrakten Begriff ein und fordern dann axiomatisch die bekannten Eigeschaften. Interessant sind hier die Axiome \verb!cardUnion0-2! bezüglich der Vereinigung von Gruppen. Da wir die ganze Zahlen recht abstrakt eingeführt haben und insbesondere kein Induktionsaxiom haben, müssen wir diese drei Axiome hier seperat fordern, obwohl sie auf Metaebene aus \verb!cardUnion0! gefolgert werden können.

\begin{lstlisting}


	Signature.
	A finite set is a set.
	
	Axiom.
	Let M be a finite set.
	Let N be a subset of M.
	N is a finite set.
	
	Axiom.
	Let f be a function such that Dom(f) is a finite set.
	Range(f) is a finite set.
	
	Axiom.
	Let M, N be finite set.
	Prod(M, N) is a finite set.
	
	Signature.
	Let M be a finite set.
	card(M) is a natural number.
	
	Axiom.
	Let M be a finite set.
	Let N be a subset of M.
	If card(M) = card(N) then M = N.
	
	Axiom.
	Let M be a set such that for all elements N of M N is a finite set.
	\-/ M is a finite set.
	
	Axiom.
	Let N1, N2 be finite sets.
	N1 \-/ N2 is a finite set.
	
	Axiom cardUnion0.
	Let N1, N2 be finite sets.
	If N1 and N2 are disjunct then card(N1 \-/ N2) = card(N1) + card(N2).
	
	Axiom cardUnion1.
	Let M be a set.
	Let N be an element of M.
	If M is a finite set such that every element of M is a finite set
	and M is a disjunct collection 
	and for all elements N1, N2 of M card(N1) = card(N2)
	then card(\-/M) = card(N)*card(M).
	
	Axiom cardUnion2.
	Let M be a set.
	Let k be an integer.
	If M is a finite set such that every element of M is a finite set
	and M is disjunct collection
	and for all elements N of M k | card(N)
	then k | card(\-/ M).
	
	Axiom.
	Let N1, N2 be finite sets.
	card(N1) = card(N2) iff there is a function f such that (f is from N1 to N2 and f is injective and f is surjective onto N2).
	
	Axiom.
	Let M be a finite set.
	If card(M) != 0 then M is not empty.
	
	Axiom.
	Let M be a finite set.
	card(M) = 1 iff there is y <<  M such that for all x << M x = y.
	
	Axiom.
	Let M be a finite set.
	Assume 1 < card(M).
	Let x be an element of M.
	There is y <<  M such that x != y.

\end{lstlisting}


\subsection{Der Satz von Lagrange}

Der Satz von Lagrange ist ein grundlegender Satz der endlichen Gruppentheorie.

\begin{lstlisting}

Definition.
A finite group is a group G such that El(G) is a finite set.

Lemma.
Let G be a finite group.
Let U be a subgroup of G.
Cosets(U, G) is a finite set.
Proof.
  Define f[g] = Coset(g, U, G) for g in El(G).
  Cosets(U, G) is a subset of  Range(f).
  Therefore the thesis.
Qed.


Definition.
Let G be a finite group.
Let U be a subgroup of G.
Index(G, U) = card(Cosets(U, G)).

Lemma.
Let G be a finite group.
Let U, V be subgroups of G such that V and U are conjugates in G.
card(U) = card(V).
Proof.
Take an element g of El(G) such that V = Conjugate(g, U, G).
Define f[u] = g *^{G} (u *^{G} Inv(g, G)) for u in U.
Let us show that f is from U to V.
  Dom(f) = U.
  Let us show that for all elements u of U f[u] is an element of V.
    Let u be an element of U.
    f[u] is an element of V.
  end.
end.

Let us show that f is injective.
  Let us show that for all elements u1, u2 of U if f[u1] = f[u2] then u1 = u2.
     Let u1, u2 be elements of U such that f[u1] = f[u2].
     We have u1 = (Inv(g, G) *^{G}  (g *^{G} (u1 *^{G} Inv(g, G)))) *^{G} g.
     We have u2 = (Inv(g, G) *^{G}  (g *^{G} (u2 *^{G} Inv(g, G)))) *^{G} g.
     Therefore u1 = (Inv(g, G) *^{G}  f[u1]) *^{G} g = (Inv(g, G) *^{G}  f[u2]) *^{G} g = u2.
  end.
end.

Let us show that f is surjective onto V.
  Let us show that for every element v of V there is an element u of U such that f[u] = v.
    Let v be an element of V.
    We can take an element u of U such that v = (g *^{G} u) *^{G} Inv(g, G).
    Hence v = f[u].
  end.
end.
qed.

Theorem Lagrange.
Let G be a finite group.
Let U be a subgroup of G.
card(El(G)) = card(U)*card(Cosets(U, G)).
Proof.
Let us show that for all elements g of El(G) card(Coset(g, U, G)) = card(U).
  Let g be an element of El(G).
  Define f[u] = g *^{G} u for u in U.
  f is from U to Coset(g, U, G).
  f is injective.
  Proof.
    Let us show that for all  elements u1, u2 of U If f[u1] = f[u2] then u1 = u2.
      Let u1, u2 be elements of U such that f[u1] = f[u2].
      We have u1 = Inv(g, G) *^{G} (g *^{G} u1) = Inv(g, G) *^{G} (g *^{G} u2) = u2.
      Thus u1 = u2.
    end.

    Therefore the thesis.
  end.

  f is surjective onto Coset(g, U, G).
  Proof.
    Let us show that for every element y of Coset(g, U, G) there is an element u of U such that f[u] = y.
      Let y be an element of Coset(g, U, G).
      Take an element u of U such that y = g*^{G} u.
      Then f[u] = y.
    end.

    Therefore the thesis.
  end.
end.

(1) Cosets(U, G) is a disjunct collection and for all elements N1, N2 of Cosets(U, G) card(N1) = card(N2).
(2) Cosets(U, G) is a finite set such that for all element N1 of Cosets(U, G) N1 is a finite set.
(3) U is an element of Cosets(U, G).

Therefore card(\-/ Cosets(U, G)) = card(U)*card(Cosets(U, G)) (by cardUnion, 1, 2, 3).
Qed.
\end{lstlisting}

\subsection{Gruppenaktionen}

Gruppenaktionen betrachten wir als Funktionen von \verb!Prod(El(G), M)! nach \verb!M! mit zusätzlichen Eigenschaften.

\begin{lstlisting}

Definition.
Let M be a set.
Let G be a group.
A group action from G on M is a function f
such that f is from Prod(El(G), M) to M
and (for every element x of M f[(One(G), x)] = x)
and for every element x of M for all elements a, b of El(G)
f[((a *^{G}  b), x)] = f[(a, f[(b, x)])].

Definition.
Let M be a set.
Let G be a group.
Let f be a function from Prod(El(G), M) to M.
Let x be an element of M.
Orbit(x, f, M, G) = { f[(a, x)] | a << El(G)}.


Definition.
Let M be a set.
Let G be a group.
Let f be a group action from G on M.
Let x << M.
Stab(x,f, M, G) = {y | y << El(G) and f[(y, x)] = x}.

Lemma.
Let M be a set.
Let G be a group.
Let f be a group action from G on M.
Let x << M.
Stab(x,f,M, G) is a subgroup of G.
Proof.

One(G) is an element of Stab(x, f, M, G).

Let us show that for all elements y, z of Stab(x, f, M, G)  z *^{G} Inv(y, G) << Stab(x, f, M, G).
  Let y, z be elements of Stab(x, f, M, G).
  We have f[(z *^{G} Inv(y, G), x)] = x.
  Therefore z *^{G} Inv(y, G) is an element of Stab(x, f, M, G).
end.

Therefore the thesis.
Qed.

Lemma.
Let M be a set.
Let G be a group.
Let f be a group action from G on M.
Let x << M.
Let g, h be elements of El(G).
If Coset(g, Stab(x, f, M, G), G) = Coset(h, Stab(x, f, M, G), G) then f[(g, x)] = f[(h, x)].


\end{lstlisting}

\subsection{Stabilisator und Orbit}

Außerhalb von Beweisen lassen sich in Naproche keine Funktionen definieren. In der herkömmlichen Mathematik werden Funktionen oft definiert und erst nachträglich auf ''Wohldefiniertheit'' bzw. Repräsentantenunabhängigkeit überprüft.
Man könnte diesen Vorgang über einen Relationsbegriff und weitere Axiome formalisieren. In diesem Text belassen wir es jedoch dabei, auf Metaebene begründet durch das vorangegange Lemma, die Existenz der folgenden Funktion als Axiom zu fordern.

\begin{lstlisting}

Axiom.
Let M be a set.
Let G be a group.
Let f be a group action from G on M.
Let x << M.
There is a function h such that
h is from Cosets(Stab(x, f, M, G), G) to Orbit(x, f, M, G)
and (for all elements i of El(G) h[Coset(i,Stab(x, f, M, G),G)] = f[(i, x)]).

Lemma.
Let G be a finite group.
Let f be a group action from G on M.
Let x << M.
Orbit(x,f, M, G) is a finite set.
Proof.
  Define h[g] = f[(g, x)] for g in El(G).
  Dom(h) is a finite set.
  Orbit(x, f, M, G) is a subset of Range(h).
  Proof.
    Let us show that every element of Orbit(x, f, M, G) is an element of Range(h).
       (1) Let y be an element of Orbit(x, f, M, G).

       We can take an element g1 of El(G) such that y = f[(g1, x)] (by 1).

       Thus y is an element of Range(h).
    end.
  end.
  Therefore Orbit(x, f, M, G) is a finite set.
Qed.

Lemma.
Let M be a set.
Let G be a finite group.
Let f be a group action from G on M.
Let x << M.
Index(G, Stab(x, f, M, G)) = card(Orbit(x, f, M, G)).
Proof.

Take a function h such that
h is from Cosets(Stab(x, f, M, G), G) to Orbit(x, f, M, G)
and (for all elements i of El(G) h[Coset(i,Stab(x, f, M, G),G)] = f[(i, x)]).

h is surjective onto Orbit(x, f, M, G).
Proof.
  Let us show that for every element y of Orbit(x, f, M, G) there is an element z of Dom(f) such that f[z] = y.
    Let y be an element of Orbit(x, f, M, G).
    Take an element i of El(G) such that f[(i, x)] = y.
    Then we have h[Coset(i,Stab(x, f, M, G),G)] = y.
  end.
end.

h is injective.
Proof.
  Let us show that for all elements h1, h2 of Cosets(Stab(x, f, M, G), G) if h[h1] = h[h2] then h1 = h2.
    Let h1, h2 be elements of Cosets(Stab(x, f, M, G), G) such that h[h1] =h[h2].
    
    Take elements g1, g2 of El(G) such that h1 = Coset(g1,Stab(x, f, M, G),G) and h2 = Coset(g2, Stab(x, f, M, G),G).
  
    Then f[(g1, x)] = f[(g2, x)].
    f[((Inv(g2, G) *^{G} g1), x)] = f[((Inv(g2, G)*^{G} g2), x)] = x.
    
    Thus Inv(g2, G) *^{G} g1 is an element of Stab(x, f, M, G).
    Therefore h1 = h2.
  end.
end.
qed.
\end{lstlisting}

\subsection{Fipunkte}

Wir führen den Begriff des Fixpunktes und der Menge der Fixpunkte einer Gruppenaktion ein und beweisen ein Lemma.


\begin{lstlisting}
	Definition.
	Let M be a set.
	Let G be a group.
	Let f be a group action from G on M.
	A fixed point of f on M on G is an element y of M such that
	for every element a of El(G) f[(a, y)] = y.
	
	Definition.
	Let M be a set.
	Let G be a group.
	Let f be a group action from G on M.
	fixedPoints(f, M, G) = {y | y is a fixed point of f on M on G}.
	
	Lemma.
	Let M be a finite set.
	Let G be a group.
	Let f be a group action from G on M.
	fixedPoints(f, M, G) is a finite set.
	Proof.
	  Let us show that  every fixed point of f on M on G is an element of M.
		Let x be a fixed point of f on M on G.
		Then x is an element of M.
	  end.
	
	   fixedPoints(f, M, G) is a subset of M.
	
	   Therefore the thesis.
	Qed.
	
	Lemma.
	Let M be a set.
	Let G be a finite group.
	Let f be a group action from G on M.
	Let x be an element of M.
	x is a fixed point of f on M on G iff card(Orbit(x, f, M, G)) = 1.
	
	
	Lemma OrbitsIntersect.
	Let M be a set.
	Let G be a group.
	Let f be a group action from G on M.
	Let x1, x2 be elements of M such that Orbit(x1, f, M, G) and Orbit(x2, f, M ,G) are not disjunct.
	x1 is an element of Orbit(x2,  f, M, G).
	Proof.
	Take y <<  M such that y << Orbit(x1, f, M, G) and y << Orbit(x2, f, M, G).
	Take g1 << El(G) such that f[(g1, x1)] = y.
	Take g2 << El(G) such that f[(g2, x2)] = y.
	
	x1 = f[(Inv(g1, G) *^{G} g1, x1)] = f[(Inv(g1, G), y)] = f[(Inv(g1, G) *^{G} g2, x2)].
	
	Therefore the thesis.
	Qed.
	
	Lemma.
	Let M be a set.
	Let G be a group.
	Let f be a group action from G on M.
	Let x1, x2 be elements of M such that Orbit(x1,  f, M, G) and Orbit(x2,  f, M, G) are not disjunct.
	Orbit(x1,  f, M, G) = Orbit(x2, f, M, G).
	Proof.
	Let us show that every element of Orbit(x1,  f, M, G) is an element of Orbit(x2,  f, M, G).
	  Let x3 be an element of Orbit(x1,  f, M, G).
	  x1 is an element of Orbit(x2,  f, M, G) (by OrbitsIntersect).
	  Thus x3 is an element of Orbit(x2,  f, M, G).
	end.
	Let us show that every element of Orbit(x2, f, M, G) is an element of Orbit(x1,  f, M, G).
	  Let x3 be an element of Orbit(x2, f, M, G).
	  x2 is an element of Orbit(x1,  f, M, G) (by OrbitsIntersect).
	  Thus x3 is an element of Orbit(x1,  f, M, G).
	end.
	Qed.
	
	Definition.
	Let M be a set.
	Let G be a group.
	Let f be a group action from G on M.
	OrbitsNotFix(f, M, G) = {Orbit(x,  f, M, G) | x is an element of M and x is not a fixed point of f on M on G}.
	
	Lemma.
	Let M be a set.
	Let G be a group.
	Let f be a group action from G on M.
	OrbitsNotFix(f, M, G) is a disjunct collection.
	
	Lemma.
	Let M be a set.
	Let G be a group.
	Let f be a group action from G on M.
	\-/ OrbitsNotFix( f, M, G) = M \\ fixedPoints(f, M, G).
	Proof.
	Let us show that every element of \-/ OrbitsNotFix( f, M, G) is an element of  M \\ fixedPoints(f, M, G).
	  Let x be an element of  \-/ OrbitsNotFix( f, M, G).
	  Take an element y of M such that x is an element of Orbit(y,  f, M, G) and y is not an element of fixedPoints(f, M, G).
	  x is an element of M.
	  x is not a fixed point of f on M on G.
	  fixedPoints(f, M , G) is a subset of M.
	  Therefore  x is an element of M \\ fixedPoints(f, M, G).
	end.
	
	Let us show that every element of M \\ fixedPoints(f, M, G) is an element of  \-/ OrbitsNotFix( f, M, G).
	  Let x be an element of M \\ fixedPoints(f, M , G).
	  x is an element of M.
	  x is not a fixed point of f on M on G.
	  Orbit(x, f, M, G) is an element of OrbitsNotFix( f, M, G).
	  x is an element of Orbit(x,  f, M, G).
	  Therefore  x is an element of  \-/ OrbitsNotFix( f, M, G).
	end.
	qed.
	
	Lemma.
	Let M be a set.
	Let G be a group.
	Let f be a group action from G on M.
	\-/  OrbitsNotFix( f, M, G) and fixedPoints(f, M, G) are disjunct.
	
	Lemma.
	Let M be a set.
	Let G be a group.
	Let f be a group action from G on M.
	(\-/ OrbitsNotFix( f, M, G)) \-/ fixedPoints( f, M, G) = M.
	
	Lemma.
	Let M be a finite set.
	Let G be a finite group.
	Let f be a group action from G on M.
	OrbitsNotFix( f, M, G) is a finite set.
	Proof.
	Define h[x] = Orbit(x,  f, M, G) for x in M.
	
	OrbitsNotFix( f, M, G) is a subset of Range(h).
	Qed.
	
	Lemma.
	Let M be a finite set.
	Let G be a finite group.
	Let f be a group action from G on M.
	card(M) = card(( \-/ OrbitsNotFix( f, M, G)) \-/ fixedPoints( f, M, G)) 
	= card(fixedPoints(f, M, G)) + card(\-/ OrbitsNotFix( f, M, G)).
	
	Signature.
	Let p be a prime.
	A group of order p is a finite group H such that
	(there is a natural number n such that card(El(H)) = p ^ n).
	
	Lemma.
	Let M be a finite set.
	Let p be a prime.
	Let G be a group of order p.
	Let f be a group action from G on M.
	card(fixedPoints(f, M, G)) = card(M) (mod p).
	Proof.
	
	\-/ OrbitsNotFix(f, M, G) is a subset of M.
	
	Let us show that p | card( \-/  OrbitsNotFix( f, M, G)).
	
	  Let us show that for all elements N1 of OrbitsNotFix( f, M, G) p | card(N1).
	
		Let N be an element of OrbitsNotFix( f, M, G).
	
		Take an element x of M such that N = Orbit(x, f, M, G).
		
		Let us show that card(N) != 1.
		  Assume the contrary.
		   
		  x is not a fixed point of f on M on G .
		  x is an element of N.
		  Thus x is a fixed point of f on M on G.
	
		  Contradiction.
		end.
	
		We have card(N) = Index(G, Stab(x, f, M, G)).
		Hence card(El(G)) = card(Stab(x,  f, M, G))*card(N) and card(N) | card(El(G)).
		Therefore p | card(N).
	  end.
	
	  (1) OrbitsNotFix( f, M, G) is a finite set such that every element of OrbitsNotFix( f, M, G) is a finite set.
	  (2) OrbitsNotFix( f, M, G) is a disjunct collection and for all elements N of OrbitsNotFix( f, M, G) p | card(N).
	
	  Therefore  p | card(\-/ OrbitsNotFix( f, M, G)) (by cardUnion2, 1, 2).
	end.
	
	We have card(M) = card(fixedPoints(f, M, G)) + card(\-/ OrbitsNotFix( f, M, G)).
	
	Therefore  card(M) = card(fixedPoints(f, M, G)) (mod p).
	qed.

\end{lstlisting}

\subsection{Eine Gruppenaktion}

Um den zweiten Satz von Sylow zu beweisen,  muss eine explizite Gruppenaktion definiert werden.

Im Gegensatz zur abstrakten Formulierung des Gruppen- und Zahlbegriffes in dieser Formalisierung lässt sich aufgrund der Formulierung der Definition von Gruppenaktion nun in Naproche zeigen, dass es sich bei dieser Funktion um eine Gruppenaktion handelt.

\begin{lstlisting}
Lemma.
Let P be a subgroup of G.
Let U be a subgroup of G.
Let u be an element of U.
Let x, y be elements of El(G) such that Coset(x, P, G) = Coset(y, P, G). 
Every element of Coset(u *^{G} x, P, G) is an element of  Coset(u *^{G} y, P, G).
Proof.
    Let i be an element of Coset(u *^{G} x, P, G).
    Take an element p of P such that i =  (u *^{G} x) *^{G} p.
    Then we have Inv(u, G) *^{G} i = Inv(u, G) *^{G} ((u *^{G} x) *^{G} p)
     =((Inv(u, G) *^{G} u ) *^{G} x) *^{G} p
    = x *^{G} p.
    Inv(u, G) *^{G} i is an element of Coset(x, P, G).
    Therefore Inv(u, G) *^{G} i is an element of Coset(y, P, G)
    and i is an element of Coset(u *^{G} y, P, G).
qed.

Lemma.
Let P be a subgroup of G.
Let U be a subgroup of G.
Let u be an element of U.
Let x, y be elements of El(G) such that Coset(x, P, G) = Coset(y, P, G). 
Coset(u *^{G} x, P, G) = Coset(u *^{G} y, P, G).
Proof.
  Every element of Coset(u *^{G} x, P, G) is an element of  Coset(u *^{G} y, P, G).
  Every element of Coset(u *^{G} y, P, G) is an element of  Coset(u *^{G} x, P, G).

  Therefore the thesis.
Qed.

\end{lstlisting}

Aufgrund des vorangegangen Lemmas führt die folgende Definition nicht zu Problemen hinsichtlich der Konsistenz der Formalisierung (Siehe 3.12).

\begin{lstlisting}

Definition.
Let P be a subgroup of G.
Let U be a subgroup of G.
Op(U, P, G) is a function f 
such that f is from Prod(El(Gr(U, G)), Cosets(P, G)) to Cosets(P, G) and
for all elements u of U for all elements x of El(G) 
f[(u, Coset(x, P, G))] = Coset(u *^{G}  x,P, G).

Lemma.
Let P be a subgroup of G.
Let U be a subgroup of G.
Op(U, P, G) is a group action from Gr(U, G) on Cosets(P, G).
Proof.
Take a function f such that f = Op(U, P, G).
Take a group H such that  H = Gr(U, G).
Take a set M such that M = Cosets(P, G).

For every element x of M we have f[(One(H), x)] = x.

Let us show that for every element x of M for all elements a, b of El(H)
 f[(a *^{H} b, x)] =  f[(a,  f[(b, x)])].
  Let x be an element of M.
  Let a, b be elements of El(H).

  Take an element g of El(G) such that x = Coset(g, P, G).

  We have f[(b, x)] = Coset(b *^{G} g,P, G).

  f[(a, f[(b, x)])] = Coset(a *^{G} (b *^{G} g),P, G).

  f[(a *^{H}  b, x)] = Coset((a *^{G} b)*^{G} g,P, G).

  Thus f[(a, f[(b, x)])] = f[(a *^{H} b, x)].
end.

Therefore the thesis.
Qed.


\end{lstlisting}

\subsection{Vorbereitung für den zweiten Satz von Sylow}

Wir führen die Begriffe des zweiten Satzes von Sylow ein und zeigen, dass zwei Sylowgruppen die gleiche Kardinalität haben.

\begin{lstlisting}
	Signature.
	Let p be a prime.
	A subgroup of G of order p is a subgroup U of G such that
	Gr(U, G) is a group of order p.
	
	Definition.
	Let p be a prime.
	Let G be a finite group.
	Syl(p, G) = {P | P is a subgroup of G of order p and  not (p | Index(G, P))}.
	
	Lemma SylSize.
	Let p be a prime.
	Let G be a finite group.
	Let P, U be elements of Syl(p, G).
	card(U) = card(P).
	Proof.
	Take natural numbers n, m such that p^n = card(U) and p^m = card(P).
	
	(1) card(El(G)) = (p^n)*Index(G, U) 
	  and card(El(G)) = (p^m)*Index(G, P) 
	  and p does not divide Index(G, U)
	  and p does not divide Index(G, P).
	
	Thus we have n = m (by DLogN, 1).
	
	Therefore the thesis.
	Qed.
	
\end{lstlisting}

\subsection{Der zweite Satz von Sylow}

Schlussendlich können wir den Beweis des zweiten Satzes von Sylow in Naproche formulieren.

\begin{lstlisting}
	
	Theorem Sylow2a.
	Let p be a prime.
	Let G be a finite group.
	Let P be an element of Syl(p, G).
	Let U be a subgroup of G of order p.
	There is an element g of El(G) such that Conjugate(g, U, G) is a subset of P.
	Proof.
	  Take a group action f from Gr(U, G) on Cosets(P, G) such that f = Op(U, P, G).
	  
	  Let us show that card(fixedPoints(f, Cosets(P, G), Gr(U, G))) !=  0.
		 We have card(fixedPoints(f, Cosets(P, G), Gr(U, G))) = Index(G, P) (mod p).
				 p does not divide Index(G, P).
		 Therefore Index(G, P) != 0 (mod p).
	  end.
	  
	  We can take an element x of fixedPoints(f, Cosets(P, G), Gr(U, G))
	  and an element g of El(G) such that x = Coset(g, P, G).
	  
	  Let us show that every element of Conjugate(Inv(g, G), U, G) is an element of P.
		Let h  be an element of Conjugate(Inv(g, G), U, G).
	
		Take an element u of U such that h = Inv(g, G) *^{G} (u *^{G}  g).
	
		We have Coset(g, P, G) = f[(u,x)] = Coset((u *^{G} g) ,P, G).
	
		Therefore Inv(g, G) *^{G} (u *^{G}  g) is an element of P.
	
		Thus h is an element of P.
	  end.
	Qed.
	
	Theorem Sylow2b.
	Let p be a prime.
	Let G be a finite group.
	Let P, U be elements of Syl(p, G).
	P and U are conjugates in G.
	Proof.
	  Take an element g of El(G) such that Conjugate(g, U, G) is a subset of P.
	
	  card(Conjugate(g, U, G)) = card(U) = card(P).
	
	  Hence Conjugate(g, U, G) = P.
	qed.
\end{lstlisting}


\newpage

\section{Vergleich}

\subsection{Direkte Gegenüberstellung}

\subsubsection{Herkömmliche Mathematik}

\begin{Theorem}
    Sei $p$ eine Primzahl und $G$ eine endliche Gruppe mit $|G|=p^{r}*m$, sodass $p\nmid m$. Sei $U \leq G$ eine $p$-Untergruppe, und sei $P \leq G$ eine $p$-Sylowgruppe. Dann gilt:
    \begin{enumerate}
        \item Es gibt ein $g\in G$ mit $$gUg^{-1}\subseteq P.$$
        \item Je zwei $p$-Sylowgruppen sind konjugiert.
    \end{enumerate}
\begin{proof}
    \begin{enumerate}
        \item Setze $X\coloneqq\fkr{G}{P}$ und betrachte die Gruppenaktion
                    $$\phi:U\times X\to X$$
                    $$(u,gP)\mapsto ugP.$$
                    Nach Lemma 1.5 gilt $$|X|=[G : P]=m\equiv |X^{G}| \mod p.$$
                    Da $p\nmid m$, gilt $X^{G}\neq\emptyset$. Es existiert also ein $g\in G$, sodass $ugP=gP$ für alle $u\in U$.
                    Folglich ist $g^{-1}Ug\subseteq P$ und damit $U$ konjugiert zu $P$ bzgl. $g^{-1}$.
        \item Dies gilt insbesondere im Falle $U\in \text{Syl}_{p}(G)$.
    \end{enumerate}
\end{proof}
\end{Theorem}

\subsubsection{Lean}

\lstset{language=lean}

\begin{lstlisting}
	lemma sylow_2 [fintype G] {p : ℕ} (hp : nat.prime p)
	(H K : set G) [is_sylow H hp] [is_sylow K hp] :
	∃ g : G, H = conjugate_set g K :=
	
	have hs : card (left_cosets K) = card G / (p ^ dlogn p (card G)) := 
	(nat.mul_right_inj (pos_pow_of_pos (dlogn p (card G)) hp.pos)).1
	$\$$ by rw [ ← card_sylow K hp, ← card_eq_card_cosets_mul_card_subgroup, card_sylow K hp, 
	nat.div_mul_cancel (dlogn_dvd _ hp.1)],
	
	have hmodeq : card G / (p ^ dlogn p (card G)) ≡ card (fixed_points H (left_cosets K)) [MOD p] := 
	eq.subst hs (mul_action.card_modeq_card_fixed_points hp (card_sylow H hp)),
	
	have hfixed : 0 < card (fixed_points H (left_cosets K)) := 
	nat.pos_of_ne_zero 
	(λ h, (not_dvd_div_dlogn (fintype.card_pos_iff.2 ⟨(1 : G)⟩) hp.1) 
	(by rwa [h, nat.modeq.modeq_zero_iff] at hmodeq)),
\end{lstlisting}


\subsubsection{Naproche}

\lstset{language=ftl, basicstyle = \fontsize{10}{13}\selectfont\ttfamily}

\begin{lstlisting}
Theorem Sylow2a.
	Let p be a prime.
	Let G be a finite group.
	Let P be an element of Syl(p, G).
	Let U be a subgroup of G of order p.
	There is an element g of El(G) such that Conjugate(g, U, G) is a subset of P.
	  Proof.
	  Take a group action f from Gr(U, G) on Cosets(P, G) such that f = Op(U, P, G).
	  
	  Let us show that card(fixedPoints(f, Cosets(P, G), Gr(U, G))) !=  0.
		 We have card(fixedPoints(f, Cosets(P, G), Gr(U, G))) = Index(G, P) (mod p).
				 p does not divide Index(G, P).
		 Therefore Index(G, P) != 0 (mod p).
	  end.
	  
	  We can take an element x of fixedPoints(f, Cosets(P, G), Gr(U, G))
	  and an element g of El(G) such that x = Coset(g, P, G).
	  
	  Let us show that every element of Conjugate(Inv(g, G), U, G) is an element of P.
		Let h  be an element of Conjugate(Inv(g, G), U, G).
	
		Take an element u of U such that h = Inv(g, G) *^{G} (u *^{G}  g).
	
		We have Coset(g, P, G) = f[(u,x)] = Coset((u *^{G} g) ,P, G).
	
		Therefore Inv(g, G) *^{G} (u *^{G}  g) is an element of P.
	
		Thus h is an element of P.
	  end.
	Qed.

	Theorem Sylow2b.
	Let p be a prime.
	Let G be a finite group.
	Let P, U be elements of Syl(p, G).
	P and U are conjugates in G.
	Proof.
	  Take an element g of El(G) such that Conjugate(g, U, G) is a subset of P.
	
	  card(Conjugate(g, U, G)) = card(U) = card(P).
	
	  Hence Conjugate(g, U, G) = P.
	qed.
\end{lstlisting}


\subsection{Beweisführung}

Der zentrale Unterschied zwischen den beiden Formalisierungen ist, dass Lean eine funktionale Programmiersprache ist und auf der Typentheorie basiert. Dies führt zu einer sehr technischen Aufbau des Lean-Beweises durch Kombination von Lambda-Termen.

Im Gegensatz dazu arbeitet das Naprochesystem in einem deklarativen Stil, d.h es handelt sich um eine Aneinanderreihung von Aussagen, die durch den internen \verb!Reasoner! sowie den externen \verb!ATP! verifiziert werden.

Dies ermöglicht es dem Naproche-Text auf der einen Seite, auf struktureller Ebene recht nah am Stil der herkömmlichen Mathematik zu bleiben.

Auf der anderen Seite ermöglicht die Beschaffenheit von Lean als Programmiersprache hier jedoch gewisse argumentative Methoden wie Symmetrie durch sogenannte ''Taktiken'' umzusetzen, die sich im deklarativen Stil von Naproche momentan nicht abbilden lassen (Siehe den Beweis in Abschnitt 3.8).

\lstset{language=lean}
\begin{lstlisting}
example (x y : ℕ) (h : x = y) : y = x :=
begin
  revert x y,
  intros,
  symmetry,
  assumption
end
\end{lstlisting}

(Beispiel eines Taktik-Beweises in Lean unter Verwendung von \ls{symmetry} \cite{bibtex.e})

\subsection{Algebraische Strukturen}

Ein weiterer Unterschied ist die Behandlung von algebraischen Strukturen hinsichtlich der Begriffsbildung.

So existiert in Lean das System der Typenklassen, während in Naproche keine bis auf einen naiven Mengen und Funktionsbegriff keine Strukturelemente bereitgestellt werden.

Während in der Formalisierung in Lean beispielsweise die Gruppen strukturell als Erweiterung des Typenklasse Monoid entstehen, werden diese in der Naproche-Formalisierung als abstrakte Notion eingeführt. Exemplarisch stellt sich hier die Behandlung der Untergruppen heraus:
\lstinline{instance subtype.group s : set α [is_subgroup] s : group s := ...} Hier wird in Lean gezeigt, dass Untergruppen eine \ls{instance} der Typenklasse \ls{group} ist. Dies sorgt dafür, dass sich Untergruppen in Lean nun ohne weitere Notation auch als Gruppen auffasen lassen.
Da Naproche keine solche Strukturen bereitstellt, benötigten wir hierfür die axiomatische geforderte Gruppe \verb!Gr(U, G)! (siehe Abschnitt 3.2).

\subsection{Funktionsdefinitionen}


Lean enthält als Funktionale Programmiersprache Möglichkeiten, Funktionen und Typklassen zu definieren und mit diesen zu arbeiten.

Das Naproche System stellt auch einen Mengen, Funktionen bereit, dieser ist jedoch sehr . So ist es zum Beispiel nicht möglich außerhalb . Dies führt zu den angesprochenen Problemen (Siehe ).


\subsection{Struktur}

In einem herkömmlichen Beweis \cite{bibtex.a} des zweiten Sylowsatzes findet man auch die Unterteilung in Kapitel welche sich in der Dateistruktur unserer Formalisierung wiederfindet. Allerdings werden im herkömmlichen Beweis grundlegende Eigenschaften von endlichen Kardinalitäten, endlichen Mengen und den ganzen Zahlen als bekannt vorrausgesetzt. Dies spiegelt sich in der Formalisierung in Naproche insofern wieder, als diese Eigenschaften axiomatisch gefordert und nicht explizit bewiesen werden, wie dies in der Lean Formalisierung praktiziert wird.

Es wäre wünschenswert, alle Dateien als Ganzes von Naproche verifizieren zu lassen. Hier scheitert das System, weswegen wir in jeder Datei jeweils die Aussagen und Definitionen der vorangegangen Dateien als Axiome ohne Beweise einbinden.

Dieser Ansatz findet sich insofern in der herkömmlichen Mathematik, als dort auch nur die Aussagen eines bereits bewiesenen Theorems zititert werden, wohingegen die exakte Ausgestaltung des Beweises meist eine untergeordnete Rolle spielt: "Nach Lemma 1.5 gilt [...]" \cite{bibtex.a}.

Im Gegensatz hierzu profitiert Lean als Programmiersprache von der Möglichkeit Bibliotheken einzubinden. Es ist inbesondere möglich, Dateien oder ganze Bibliotheken durch \\ \verb!leanpkg build! in \verb!.olean! Binärdateien zu übersetzen, die vom Lean dann weitaus schneller verifiziert werden können. Dies ermöglicht es, mit umfangreichen Bibliotheken wie der mathlib \cite{bibtex.d} interaktiv zu arbeiten.

\subsection{Lesbarkeit}
In der vorangegangen Gegenüberstellung ist erkennbar, dass der deklarative Stil der Herangehensweise der herkömmlichen Mathematik ähnelt. So ist bis auf Layout- und Gestaltungsebene eine große oberflächliche Ähnlichkeit zwischen den Beweisen zu erkennen.
\\Betrachte:
\medskip

Nach Lemma 1.5 gilt $$|X|=[G : P]=m\equiv |X^{G}| \mod p.$$

\lstset{language=ftl, basicstyle = \fontsize{10}{13}\selectfont\ttfamily}
\begin{lstlisting}

    We have card(fixedPoints(f, Cosets(P, G), Gr(U, G))) = Index(G, P) (mod p).

\end{lstlisting}

\medskip

Im Gegensatz hierzu lässt sich die Formalisierung in Lean nur mit einer gewissen Vorkenntnis in funktionaler Programmierung und dem Beweisen mithilfe von Taktiken verstehen.


\subsection{Overloading}

Ein Vorteil von Lean gegenüber Naproche / ForTheL hinsichtlich der Lesbarkeit ist die Arbeit des ''Elaborators''. Aufgrund der strikten Typisierung ist Lean in der Lage, beispielsweise bei Ausdrücken der Form $a * b$ mit $a, b : G$ selbstständig zu ermitteln, dass es sich bei $*$ um die Verknüpfung von G handelt. Da dies in Naproche nicht möglich ist, entstehen sperrige Ausdrücke wie beispielsweise \verb!fixedPoints(Op(U, P, G), Cosets(P, G), Gr(U, G))!, die die Lesbarkeit des Naprochetextes vermindern.
In der herkömmlichen Mathematik findet sich hier oft ein Kompromiss. So werden an einigen Stellen die Abhängigkeiten gekennzeichnet, wie zum Beispiel im Ausdruck $\text{Syl}_{p}(G)$, während an anderen Stellen, wie in \textit{Je zwei $p$-Sylowgruppen sind konjugiert}, aus dem Kontext ersichtlich wird, welche Gruppe gemeint ist.

\subsection{User Experience}

Wir wollen nun einige Aspekte des Arbeitens mit den beiden Systemen beschreiben.

Ein Punkt der hier eine Rolle spielt ist die Stabilität der Systeme. Solange man die gleiche Lean Version verwendet, kann man einen einmal geschrieben Leantext in verschiedenen Umgebungen verifizieren, da durch das .
Im Gegensatz hierzu ist das Verifizieren in Naproche sehr instabil. So führt das verändern von wenigen Zeilen im Quelltext häufig dazu, dass sich Aussagen an anderen Stellen, die vorher verifiziert wurden, nicht mehr verifiziert werden. Insbesondere ist hier das Zusammenarbeiten mehrerer Personen mit verschiedenen Betriebssystemen kritisch, da nach unserer Erfahrung unter Linux/Mac verifizierte Dateien unter Windows oftmals nicht verifiziert werden konnten. 

Hier scheint insbesondere der \verb!Reasoner! in Naproche eine Rolle zu spielen, der in unserer Arbeit große Schwierigkeiten hatte, Funktionsterme auf ontologische Korrektheit zu überprüfen, weswegen wir deren Einsatz auf ein Minimum reduzieren mussten.


So ist ursprüngliche Lean Datei \cite{bibtex.c} mit der Lean Version 3.4.2 nicht mehr kompatibel.

Schlechte Fehlermeldungen

Dokumentationen.

\newpage

\section{Diskussion}

\subsection{Formalisierungskonventionen}

Es ist aufgefallen, so ermöglichen gemeinsame Definition von mathematischen Begriffen

Ein Beispiel hierfür ist die Implementierung der Nebenklassen. Hier nutzen verschiedene Ansätze, die jedoch auf Metaebene äquivalent sind.

interessant hier Möglichkeiten zu schaffen, andere Formaliserungen zu referenziern / einzubinden.

Interessant in diesem Kontext ist das Projekt Formal Abstracts \cite{bibtex.b}

\subsection{Vorschläge zur Weiterentwicklung an Naproche}

Als Resultat des Formalisierungsprozesses sind einige Ideen für die Weiterentwicklung des Naprochesystems entstanden.

\begin{itemize}
\item So . Es wäre wünschenswert eine kanonischen Weg zu haben, in Naproche mit algebraischen Strukturen umzugehen. Auch einen Quotientenbegriff.

\item Definitionen von Funktionen undggf anderen mathematischen Objekten internalisieren.

\item Verbesserung des Reasoners inbesondere hinsichtlich von Funktionenstermen. So wurde in einer früheren Version des Formalisierung des Sylowsatzes 



\item Für die Einbindung von anderen Dateien existiert bereits der \verb!read! Befehl. Dieser kann allerdings in der momentanen Ausführung nur auf Dateien im \verb!examples! Ordner zugreifen.
Hier wäre es wünschenswert, auch auf andere Verzeichnisse zugreifen zu können.

\item Hinsichtlich dem Einlesen von Datein ist eine weitere Idee, eine Möglichkeit zu schaffen, bereits verifizierte Texte einzulesen, ohne sie erneut verifizieren zu müssen.
Dies führt momentan dazu, dass



\item Bibliotheken vorkompilieren: erster Schritt: read Befehl
\item Exportieren von Theoremen / Definitionen ... Speichern des Beweises zum späteren schnellen Zugriff wie durch olean Dateien.

\item Unterscheiden von Axiomen und "Annahmen"
\item Error Messages
\item Betriebsysteme unterschiedliche Ergebnisse <- Überarbeiten (read, Funktionalität des Reasoners
\item Dokumentation

\end{itemize}

\subsection{Lesbarkeit als Ziel}

Unsere Formalisierung (mit Latex Typesetting) sehr ähnlich zu Schröers Algebraskript.
Der deklarative Stil ermöglicht dies.
Lean in der Hinsicht anpassen.

Interessant, den Ansatz von Lean auf natürlicherer Sprachebene.

\bibliography{biblio}


\end{document}