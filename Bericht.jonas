\documentclass[a4paper,12pt]{scrartcl}

\usepackage[ngerman]{babel} % Deutsche Einstellungen
\usepackage[utf8]{inputenc}	% uft-8 Eingabe
\usepackage[T1]{fontenc} 	% Korrekte Ausgabefonts im Ausgabedokument
\usepackage{csquotes}		% Setzen von Anführungsstrichen
\usepackage{color}

\renewcommand{\labelenumi}{(\roman{enumi})}

% a) Mathematikpakete
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{dsfont}
\usepackage[amsthm,thmmarks]{ntheorem}
\usepackage{amscd}
\usepackage{pictexwd,dcpic} % Für (kommutative u.ä.) Diagramme
\usepackage{amsxtra}% Weitere Extrasymbole
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[varg]{txfonts}
\usepackage{verbatim}
\usepackage{MnSymbol}
\usepackage{xfrac}
\usepackage{faktor}
\usepackage{xparse}

% Lean
%\usepackage[utf8x]{inputenc}
%\usepackage{amssymb}

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.0, 0.1, 0.6}    % red {0.7, 0.1, 0.1}
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean}

% b) Lemma, Satz, Theorem usw. 
%\theoremstyle{plain}
\newtheorem{Theorem}{Theorem}[section]
\newtheorem{Satz}[Theorem]{Satz}
\newtheorem{Lemma}[Theorem]{Lemma}
\newtheorem{Korollar}[Theorem]{Korollar}
\newtheorem*{Definition}[Theorem]{}
\newtheorem*{Folgerung}[Theorem]{Folgerung}
\newtheorem*{Behauptung}[Theorem]{Behauptung}
\newtheorem*{Beispiel}{Beispiel}   

\newcommand{\st}{\ \mid\ }
\newcommand{\sd}{\, : \,}
\newcommand{\R}{\mathbb R}
\newcommand{\C}{\mathbb C}
\newcommand{\N}{\mathbb N}
\newcommand{\Z}{\mathbb Z}
\newcommand{\Q}{\mathbb Q}
\newcommand{\E}{\mathbb E}
\newcommand{\Pm}{\mathbb P}
\newcommand{\fF}{\mathfrak{F}}
\newcommand{\df}[1]{\textcolor{blue}{\textbf{#1}}}
\newcommand{\sr}{S(\mathbb{R})}
\newcommand{\ri}{\int_{\R}}
\newcommand{\ra}{\longrightarrow}
\newcommand{\e}{e^{2\pi i\xi x}}
\newcommand{\me}{e^{-2\pi i\xi x}}
\newcommand{\fa}{\;\forall\,}
\newcommand{\Mod}[1]{\ (\mathrm{mod}\ #1)}
\newcommand{\ls}[1]{\lstinline|#1|}

\DeclareDocumentCommand{\fkr}{s m O{0.3} m O{-0.5}}{% \newfaktor[*]{#2}[#3]{#4}[#5] -> #2/#4
	\setbox0=\hbox{\ensuremath{#2}}% Store numerator
	\setbox1=\hbox{\ensuremath{\diagup}}% Store slash /
	\setbox2=\hbox{\ensuremath{#4}}% Store denominator
	\raisebox{#3\ht1}{\usebox0}% Numerator
	\mkern-4mu\ifthenelse{\equal{#1}{\BooleanTrue}}% Slash /
	{\diagup}% regular \faktor slash
	{\rotatebox{-33}{\rule[#5\ht0]{0.3pt}{-#5\ht0+#3\ht0+\ht0}}}% tilted rule as a slash
	\mkern-0mu%
	\raisebox{#5\ht1}{\usebox2}% Denominator
}

\title{Eine Formalisierung des zweiten Satzes von Sylow aus der Gruppentheorie in Naproche im Vergleich zu einer Implementierung in Lean}

\author{Moritz Hartlieb, Jonas Lippert}

\begin{document}
\pagenumbering{gobble}
\maketitle
\newpage
\pagenumbering{arabic}

\section{Einleitung}

In der vorliegenden Arbeit stellen wir die Formalisierung des zweiten Sylow-Satzes in der Sprache Lean vor und vergleichen sie mit einer eigenen Formalisierung in Naproche.

Zu Beginn seien die wichtigsten Definitionen und Resultate der Gruppentheorie skizziert auf Basis des Skripts \enquote{Eine Einführung in die Algebra
	(Skript, WS 19/20, Bonn)} von Prof. Dr. Jan Schröer [1].

\subsection{Theoretische Grundlagen}
	Eine \df{Gruppe} ist eine Menge $G$ zusammen mit einer Abbildung $$\circ: G\times G\to G$$ $$(g,h) \mapsto g\circ h = gh$$ sodass gilt:
	\begin{enumerate}
		\item $\circ$ ist assoziativ.
		\item Es gibt ein neutrales Element $e\in G$, sodass $e\circ g=g=g\circ e$ für alle $g\in G$.
		\item Für alle $g\in G$ existiert ein inverses Element $g^{-1}\in G$, sodass $g\circ g^{-1}=g^{-1}\circ g=e$. 
	\end{enumerate}
	
	Eine \df{Untergruppe} H von G, H $\leq$ G, ist eine Teilmenge von G mit
	\begin{enumerate}
		\item $e\in H$.
		\item H ist abgeschlossen bzgl. $\circ$ und Inversenbildung.
	\end{enumerate}
	
	Seien H $\leq$ G gegeben. Für $g \in G$ ist $$gH\coloneqq\{gh\st h\in H\}$$ die \df{Nebenklasse} von H zu g. Es bezeichne $\fkr{G}{H}$ die Klasse der Nebenklassen von H. Weiter sei $$[G : H] \coloneqq |\fkr{G}{H}|$$ der \df{Index} von H zu G.\\\\
	Zwei Untergruppen $H_{1}$ und $H_{2}$ von $G$ sind \df{konjugiert}, falls es ein $g\in G$ gibt
	mit $$H_{1}=gH_{2}g^{-1}\coloneqq \{g\ h\ g^{-1}\st h\in H\}.$$
	
	\begin{Lemma}
		Seien H $\leq$ G gegeben. Für $g_{1}, g_{2}\in G$ gilt:
		\begin{enumerate}
			\item $g_{1}H \cap g_{2}H \neq \emptyset \iff g_{1}H = g_{2}H \iff g_{1}^{-1}g_{2}\in H$
			\item Für alle $g\in G$ is die Abbildung $$H \to gH$$ $$h \mapsto gh$$ bijektiv. Insbesondere gilt im endlichen Fall $|H|=|gH|$.
		\end{enumerate}
	\begin{flushright}
		$\square$
	\end{flushright}
	\end{Lemma}
	
	\begin{Lemma}[Lagrange]
		Seien H $\leq$ G endlich. Dann folgt aus vorherigem Lemma:
		$$|G|=[G : H] \cdot |H|.$$
	\begin{flushright}
		$\square$
	\end{flushright}
	\end{Lemma}
	
	Für eine Gruppe $G$ und eine nichtleere Menge $X$ ist die Abbildung
	$$\phi:G\times X \to X$$
	$$(g,x) \mapsto g.x$$
	eine \df{Gruppenaktion}, falls gilt:
	\begin{enumerate}
		\item $1.x=x$ für alle $x\in X$.
		\item $(gh).x=g.(h.x)$ für alle $g,h\in G$ und $x\in X$.
	\end{enumerate}
	Weiter definieren wir für $x\in X$:
	\begin{enumerate}
		\item den \df{Orbit} $G.x\coloneqq \{g.x\st g\in G\}$ von $x$,
		\item den \df{Stabilisator} $G_{x}\coloneqq \{g\in G\st g.x=x\}$ von $x$,
		\item die Menge der \df{Fixpunkte} $X^{G}\coloneqq\{x\in X\st g.x=x\text{ für alle }g\in G\}$ von $X$.
	\end{enumerate}
	
	\begin{Lemma}
		Sei $G$ eine Gruppe und $X$ nichtleer. Die Funktion
		$$\fkr{G}{G_{x}} \to G.x$$
		$$(g\ G_{x})\mapsto g.x$$
		ist bijektiv.
	\begin{flushright}
		$\square$
	\end{flushright}
	\end{Lemma}
	
	Wie wir in Lemma 1.1 gesehen haben, ist eine Gruppe $G$ disjunkte Vereinigung der Nebenklassen bzgl. einer Untergruppe $H\leq G$. Zusammen mit Lemma 1.3 erhalten wir, dass $X$ disjunkte Vereinigung der Orbits bzgl. einer Gruppenaktion ist und die Kardinalität der Orbits entsprechend Lagrange die Gruppenordnung teilen müssen.
	
	\begin{Lemma}[Bahnenformel]
		Sei $G$ eine endliche Gruppe, sei $X\neq\emptyset$ endlich und seien $x_{1},...,x_{n}$ gegeben, sodass $X$ disjunkte Vereinigung der $G.x_{i}$ ist. Dann gilt 
		$$|X|=\sum_{i=1}^{n}[G:G_{x_i}]=|X^{G}|+\sum\limits_{{1\leq i\leq n} \atop x_{i}\notin X^{G}} [G:G_{x_i}].$$
	\begin{flushright}
		$\square$
	\end{flushright}
	\end{Lemma}
	
	Falls $G$ eine $p$-Gruppe ist, das heißt $|G|=p^{r}$ für eine Primzahl $p$ und ein $r\in\N$, dann folgt:
	\begin{Lemma}
		$$|X| \equiv |X^{G}| \mod p.$$
	\begin{flushright}
		$\square$
	\end{flushright}
	\end{Lemma}
	Für eine Gruppe $G$ mit $|G|=p^{r}m$, wobei $p$ prim und $p\nmid m$, ist die Menge der \df{$p$-Sylowgruppen} definiert durch
	$$\text{Syl}_{p}(G)\coloneqq\{P\ \leq\ G\st \}.$$
	
	Wir können nun den zweiten Satz von Sylow definieren:
	\begin{Theorem}
		Sei $p$ eine Primzahl und $G$ eine endliche Gruppe mit $|G|=p^{r}*m$, sodass $p\nmid m$. Sei $U \leq G$ eine $p$-Untergruppe, und sei $P \leq G$ eine $p$-Sylowgruppe. Dann gilt:
		\begin{enumerate}
			\item Es gibt ein $g\in G$ mit $$gUg^{-1}\subseteq P.$$
			\item Je zwei $p$-Sylowgruppen sind konjugiert.
		\end{enumerate}
	\begin{proof}
		\begin{enumerate}
			\item Setze $X\coloneqq\fkr{G}{P}$ und betrachte die Gruppenaktion
						$$\phi:U\times X\to X$$
						$$(u,gP)\mapsto ugP.$$
						Nach Lemma 1.5 gilt $$|X|=[G : P]=m\equiv |X^{G}| \mod p.$$
						Da $p\nmid m$, gilt $X^{G}\neq\emptyset$. Es existiert also ein $g\in G$, sodass $ugP=gP$ für alle $u\in U$.
						Folglich ist $g^{-1}Ug\subseteq P$ und damit $U$ konjugiert zu $P$ bzgl. $g^{-1}$.
			\item Dies gilt insbesondere im Falle $U\in \text{Syl}_{p}(G)$.
		\end{enumerate}
	\end{proof}
	\end{Theorem}

\subsection{Vorüberlegungen zur Formalisierung}
Es werden also zunächst Grundbegriffe der Gruppentheorie, endliche Mengen sowie natürliche Zahlen, Primzahlen und Modulo-Rechnung benötigt. Hierzu bieten sich unterschiedliche Herangehensweisen an. 
Es stellt sich heraus, dass Naproche für kleine Theorien gut geeignet ist, deren Grundlagen axiomatisch eingeführt werden, die ihrerseits in einer eigenen Theorie entwickelt werden (können). Die Implementierung in Lean baut hingegen auf bereits formalisierte Grundlagen auf und ist somit Teil einer einzigen großen Theorie der Mathematik. 

Interessant ist die Formalisierung von Nebenklassen. Im Sinne einer kleinen Theorie bietet sich in Naproche eine direkte Konstruktion an: $$Coset\left(g, H, G\right) \coloneqq \left\{\,g *^{G} h \st h << H\,\right\}.$$ Anschließend ist zu zeigen, dass $G$ disjunkte Vereinigung von Nebenklassen bzgl. einer beliebigen Untergruppe $H$ ist.
In Lean wird dagegen bzgl. einer Untergruppe $S$ von $G$ folgende Äquivalenzrelation auf $G$ eingeführt: $$x\sim_{S} y :\Leftrightarrow x^{-1}*y\in S.$$
Lean erlaubt uns, den Quotient $\fkr{G}{\sim_{S}}[-0.2]$ zu betrachten. Hier wird Lemma 1.1 implizit verwendet.
\paragraph*{}
Im Folgenden wird zunächst auf die jeweiligen Formalisierungen im Detail eingegangen. Anschließend sollen Vor- und Nachteile der jeweiligen Sprachen verglichen und diskutiert werden.


\newpage
\section{Formalisierung in Lean}
	\subsection{Quotienten in Lean}
	Endliche Mengen und Nebenklassen sind in Lean als Quotient formalisiert.
	In der core-Library von Lean sind folgende Konstanten definiert:
	\begin{lstlisting}
		constant quot : Π {α : Sort u}, (α → α → Prop) → Sort u
		constant quot.mk :
		Π {α : Sort u} (r : α → α → Prop), α → quot r
		axiom quot.ind :
		∀ {α : Sort u} {r : α → α → Prop} {β : quot r → Prop},
		(∀ a, β (quot.mk r a)) → ∀ (q : quot r), β q
		axiom quot.sound :
		∀ {α : Type u} {r : α → α → Prop} {a b : α},
		r a b → quot.mk r a =$\hspace*{0cm}$ quot.mk r b
		constant quot.lift :
		Π {α : Sort u} {r : α → α → Prop} {β : Sort u} (f : α → β)),
		(∀ a b, r a b → f a =$\hspace*{0cm}$ f b) → quot r → β
	\end{lstlisting}
	Die Klasse von \lstinline{a} in \lstinline{quot r }wird durch \lstinline{quot.mk r a }erzeugt.
	Das Induktionsaxiom stellt sicher, dass alle Elemente von \lstinline{quot r }von der Form \lstinline{quot.mk r a }sind.
	Die Lifting-Eigenschaft erlaubt es, geeignete Funktionen auf \lstinline{quot r }zu liften.\\
	Ein \lstinline{setoid $\alpha$ }ist ein Typ \lstinline{$\alpha$} zusammen mit einer Äquivalenzrelation:
	\begin{lstlisting}
	class setoid (α : Sort u) :=
	(r : α → α → Prop) (iseqv : equivalence r)
	\end{lstlisting} 
	Der \lstinline{quotient s }auf einem \lstinline{s : setoid $\alpha$ }ist dann der Quotient bzgl. einer Äquivalenzrelation:
	\begin{lstlisting}
	def quotient {α : Sort u} (s : setoid α) :=
	@quot α setoid.r
	\end{lstlisting}
	Die obigen Eigenschaften von \lstinline{quot} werden anschließend auf \lstinline|quotient| übertragen.
	
	\subsection{Endliche Mengen in Lean}
	Endliche Mengen werden auf Basis von Listen definiert. Zunächst erhält man Multimengen als Quotienten, indem Permutationen mit Hilfe der Äquivalenzrelation \lstinline|perm| miteinander identifiziert werden:
	\begin{lstlisting}
	inductive perm : list α → list α → Prop
	| nil   : perm [] []
	| skip  : Π (x : α) {l₁ l₂ : list α},
											perm l₁ l₂ → perm (x::l₁) (x::l₂)
	| swap  : Π (x y : α) (l : list α), perm (y::x::l) (x::y::l)
	| trans : Π {l₁ l₂ l₃ : list α}, perm l₁ l₂ → perm l₂ l₃ → perm l₁ l₃
	\end{lstlisting}
	Unter Verwendung des Beweises \lstinline|perm.eqv|, dass \lstinline|perm| eine Äquivalenzrelation ist, wird eine Instanz von \lstinline|setoid list $\alpha$ |eingeführt, welche dann in der Definition der Multimenge Verwendung findet:
	\begin{lstlisting}
	instance is_setoid (α) : setoid (list α) :=
	setoid.mk (@perm α) (perm.eqv α)
	
	def {u} multiset (α : Type u) : Type u :=
	quotient (list.is_setoid α)
	\end{lstlisting}
	Eine Multimenge wird zur endlichen Menge, wenn sie keine Duplikate beinhaltet:
	\begin{lstlisting}
	structure finset (α : Type*) :=
	(val : multiset α)
	(nodup : nodup val)
	\end{lstlisting}
	Die Definition von \lstinline|nodup| für Multimengen basiert auf \lstinline|nodup| für Listen. 
	\begin{lstlisting}
	def nodup : list α → Prop := pairwise (≠)
	\end{lstlisting}
	Hierbei prüft \lstinline|pairwise|, ob die Relation \lstinline|$\neq$| paarweise gilt.
	\begin{lstlisting}
	variables (R : α → α → Prop)
	inductive pairwise : list α → Prop
	| nil {} : pairwise []
	| cons : ∀ {a : α} {l : list α}, (∀ a' ∈ l, R a a') → pairwise l → pairwise (a::l)
	\end{lstlisting}
	Jetzt wird \lstinline|nodup| für Listen auf Multimengen geliftet. Dazu werden \lstinline|quot.lift$\_$on| folgende Parameter übergeben: der Quotient \lstinline|s|, die zu liftende Funktion \lstinline|nodup| und ein Beweis, dass Permutation keine Duplikate erzeugt: Aus den zwei Listen \lstinline|s t| und dem Beweis \lstinline|p|, dass diese in Relation bzgl. \lstinline|perm| zueinander stehen, erzeugt \lstinline|perm$\_$nodup| die Äquivalenz \lstinline|nodup s $\Leftrightarrow$ nodup t|. Dann wird das Lean-interne Axiom \lstinline|propext| verwendet, nach dem äquivalente Propositionen gleich sind.
	(Die Rechtsklammerung bei der Funktionseinsetzung wird hier durch $\$$ gewährleistet.)
	\begin{lstlisting}
	def nodup (s : multiset α) : Prop :=
	quot.lift_on s nodup (λ s t p, propext $\$$ perm_nodup p)
	
	def quot.lift_on {α : Sort u} {β : Sort v} {r : α → α → Prop} 
	(q : quot r) (f : α → β) (c : ∀ a b, r a b → f a =$\hspace*{0cm}$ f b) : β 
	
	theorem perm_nodup {l₁ l₂ : list α} : l₁ ~ l₂ → 
	(nodup l₁ ↔ nodup l₂)
	\end{lstlisting}
	Der Beweis von \lstinline|perm$\_$nodup| kann in perm.lean nachgelesen werden.
	In der Regel wird nicht \ls{finset} direkt verwendet, sondern die Typenklasse \ls{fintype}, sodass der Typ \ls{$\alpha$} selber endlich ist.
	\begin{lstlisting}
	class fintype (α : Type*) :=
	(elems : finset α)
	(complete : ∀ x : α, x ∈ elems)
	\end{lstlisting}
	
	
	\subsection{MOD in Lean}
	%Um die Formalisierung von \lstinline|a ≡ b [MOD n]| zu illustrieren, wollen wir den %Beweis des folgenden Lemmas nachvollziehen:
	%\begin{lstlisting}
	%lemma mod_zero (a : nat) : a % 0 =$\hspace*{0cm}$ a :=
	%begin
	%rw mod_def,
	%have h : ¬ (0 < 0 ∧ 0 ≤ a),
	%simp [lt_irrefl],
	%simp [if_neg, h]
	%end
	%\end{lstlisting}
	Die Definition von $x\Mod{y}$ auf den natürlichen Zahlen basiert auf der Wohlfundiertheit der $<$-Relation auf $\N$: 
	\begin{lstlisting}
	inductive acc {α : Sort u} (r : α → α → Prop) : α → Prop
	| intro (x : α) (h : ∀ y, r y x → acc y) : acc x
	
	parameters {α : Sort u} {r : α → α → Prop}
	
	local infix `≺`:50    := r
	
	inductive well_founded {α : Sort u} (r : α → α → Prop) : Prop
	| intro (h : ∀ a, acc r a) : well_founded
	
	class has_well_founded (α : Sort u) : Type u :=
	(r : α → α → Prop) (wf : well_founded r)
	\end{lstlisting}
	Ein Element \lstinline|x : $\alpha$| kann nur die Eigenschaft \lstinline|acc| haben, falls ein \enquote{kleinstes} Element bzgl. der Relation \lstinline|R| existiert. Entsprechend wird ein Rekursions- und Induktionsprinzip für wohlfundierte Relationen eingeführt, auf die hier nicht näher eingegangen werden soll. Wichtig ist der Spezialfall, dass sich über wohlfundierte Relationen Funktionen definieren lassen (siehe \lstinline|def fix| weiter unten):
	\begin{lstlisting}
	parameter hwf : well_founded r
	variable {C : α → Sort v}
	variable F : Π x, (Π y, y ≺ x → C y) → C x
	
	def fix_F (x : α) (a : acc r x) : C x :=
	acc.rec_on a (λ x₁ ac₁ ih, F x₁ ih)
	\end{lstlisting}
	Die Konstruktion des Fixpunktes nimmt gemäß \lstinline|acc.rec_on| einen Beweis \lstinline|a| für \lstinline|acc r x| und liefert \lstinline|C x|, falls folgender Sachverhalt gegeben ist:
	\begin{lstlisting}
	($\Pi$ ($x_{1}$ : $\alpha$), ($\forall$ (y : $\alpha$), r y $x_{1}$ $\to$ acc r y) $\to$ 
	($\Pi$ (y : $\alpha$), r y $x_{1}$ $\to$ C y) $\to$ C $x_{1}$)
	\end{lstlisting}
	Durch \lstinline|acc.rec_on| erhalten wir über den Konstruktor \lstinline|intro|:
	\begin{enumerate}
		\item[] \lstinline|$x_{1}$ : $\alpha$|
		\item[] \lstinline|$ac_{1}$ : $\forall$ (y : $\alpha$), r y $x_{1}$ $\to$ acc r y|
		\item[] \lstinline|ih : $\Pi$ (y : $\alpha$), r y $x_{1}$ $\to$ C y|
	\end{enumerate}
	\lstinline|F| liefert das Gewünschte. Wir können die Fixpunkteigenschaft nun auf wohlfundierte Relationen übertragen:
	\begin{lstlisting}
	variables {α : Sort u} {C : α → Sort v} {r : α → α → Prop}
	
	def fix (hwf : well_founded r) (F : Π x, (Π y, r y x → C y) → C x) (x : α) : C x :=
	fix_F F x (apply hwf x)
	\end{lstlisting}
	Ist eine Funktion \lstinline|F| gegeben, welche die Werte \lstinline|C x| für bekannte Werte \lstinline|C y| der \enquote{kleineren} Elemente \lstinline|y $\prec$ x| liefert, so ist nach \lstinline|fix| die Funktion \lstinline|C| für alle \lstinline|x : $\alpha$| definiert. 
	Für \lstinline|F| setzen wir
	\begin{lstlisting}
	private def mod.F (x : nat) (f : Π x₁, x₁ < x → nat → nat) (y : nat) : nat :=
	if h : 0 < y ∧ y ≤ x then f (x - y) (div_rec_lemma h) y else x
	\end{lstlisting}
	und damit \lstinline|C| auf \lstinline|$\N\to\N\to\N$|. Hier wurde folgendes Lemma verwendet:
	\begin{lstlisting}
	div_rec_lemma {x y : nat} : 0 <	 y ∧ y ≤ x → x - y < 	x.
	\end{lstlisting}
	Weiter können wir \lstinline|mod| und damit eine Instanz der Typenklasse \lstinline|class has$\_$mod |definieren, die bereits in \lstinline|core.lean| vordefiniert ist. Sie besitzt einzig den Konstruktor \lstinline|has$\_$mod.mod : $\N\to\N\to\N$|.
	\begin{lstlisting}
	protected def mod := fix lt_wf mod.F
	
	instance : has_mod nat :=
	⟨nat.mod⟩
	\end{lstlisting}
	Die Infixnotation für \lstinline|has$\_$mod.mod n m |ist \lstinline|n % m|.
	Schließlich wird \lstinline|a ≡ b [MOD n]| definiert:
	\begin{lstlisting}
	def modeq (n a b : ℕ) := a % n =$\hspace*{0cm}$ b % n
	
	notation a ` ≡ `:50 b ` [MOD `:50 n `]`:0 := modeq n a b
	\end{lstlisting}




	\subsection{Gruppen in Lean}
	Gruppen werden sukzessive durch Erweiterungen von \lstinline|type calsses| definiert:
	\begin{lstlisting}
	class has_mul (α : Type u) := (mul : α → α → α)
	
	infix * := has_mul.mul
	
	class semigroup (α : Type u) extends has_mul α :=
	(mul_assoc : ∀ a b c : α, a * b * c = a * (b * c))
	
	class monoid (α : Type u) extends semigroup α, has_one α :=
	(one_mul : ∀ a : α, 1 * a = a) (mul_one : ∀ a : α, a * 1 = a)
	
	class group (α : Type u) extends monoid α, has_inv α :=
	(mul_left_inv : ∀ a : α, a⁻¹ * a = 1)
	\end{lstlisting}
	Entsprechendes gilt für Untergruppen
	\begin{lstlisting}
	variables {α : Type*} [monoid α] {s : set α}
	
	class is_submonoid (s : set α) : Prop :=
	(one_mem : (1:α) ∈ s)
	(mul_mem {a b} : a ∈ s → b ∈ s → a * b ∈ s)
	
	class is_subgroup (s : set α) extends is_submonoid s : Prop :=
	(inv_mem {a} : a ∈ s → a⁻¹ ∈ s)
	\end{lstlisting}
	und Gruppenaktionen:
	\begin{lstlisting}
	class has_scalar (α : Type u) (γ : Type v) := 
	(smul : α → γ → γ)

	infixr ` • `:73 := has_scalar.smul
	
	class mul_action (α : Type u) (β : Type v) [monoid α] extends has_scalar α β :=
	(one_smul : ∀ b : β, (1 : α) • b = b)
	(mul_smul : ∀ (x y : α) (b : β), (x * y) • b = x • y • b)
	\end{lstlisting}
	Es folgen die üblichen Definitionen bzgl. Gruppenaktionen.
	\begin{lstlisting}
	variables (α) [monoid α] [mul_action α β]
	
	def orbit (b : β) := set.range (λ x : α, x • b)
	
	variables (α) (β)
	
	def stabilizer (b : β) : set α :=
	{x : α | x • b = b}
	
	def fixed_points : set β := {b : β | ∀ x, x ∈ stabilizer α b}
	\end{lstlisting}
	Nebenklassen werden als Quotient bzgl. der Relation \lstinline|left_rel| definiert:
	\begin{lstlisting}
	def left_rel [group α] (s : set α) [is_subgroup s] : setoid α :=
	⟨λ x y, x⁻¹ * y ∈ s,
	assume x, by simp [is_submonoid.one_mem],
	assume x y hxy,
	have (x⁻¹ * y)⁻¹ ∈ s, from is_subgroup.inv_mem hxy,
	by simpa using this,
	assume x y z hxy hyz,
	have x⁻¹ * y * (y⁻¹ * z) ∈ s, from is_submonoid.mul_mem hxy hyz,
	by simpa [mul_assoc] using this⟩
	
	def left_cosets [group α] (s : set α) [is_subgroup s] : Type* := quotient (left_rel s)
	\end{lstlisting}
	Für eine Untergruppe \ls{H} von \ls{G} ist dann \ls{left_rel H} ein \ls{setoid G} mit entsprechender Relation und dem zugehörigen Beweis, dass es sich um eine Äquivalenzrelation handelt.
	Mithilfe dieser Definition wird eine Instanz von \ls{fintype} bzgl. \lstinline|left_costes H| erstellt:
	\begin{lstlisting}
	noncomputable instance [fintype G] (H : set G) [is_subgroup H] :  fintype (left_cosets H) := 
	quotient.fintype (left_rel H)
	\end{lstlisting}
	Der Grund dafür, dass die Instanz als \ls{noncomputable} markiert werden muss, ist die Verwendung von \ls{decidable.eq} in \ls{quotient.fintype}. Das geht auf den Umstand zurück, dass das Bild einer Funktion auf einem endlichen Typ wieder ein endlicher Typ \ls{$\beta$} ist. Hierbei wird das Bild zunächst als Multimenge betrachtet. Anschließend werden eventuelle Duplikate durch den Operator \ls{to_finset} entfernt, was die Entscheidbarkeit der Gleichheitsrelation auf $\beta$ voraussetzt.
	Um den 2. Sylowsatz in Lean zu formulieren, fehlen noch die Definitionen des \ls{conjugate_set} und der $p$-Sylowgruppen:
	\begin{lstlisting}
	def conjugate_set (x : G) (H : set G) : set G :=
	(λ n, x⁻¹ * n * x) ⁻¹' H
	
	class is_sylow [fintype G] (H : set G) {p : ℕ} (hp : prime p) extends is_subgroup H : Prop := 
	(card_eq : card H = p ^ dlogn p (card G))
	
	lemma sylow_2 [fintype G] {p : ℕ} (hp : nat.prime p)
	(H K : set G) [is_sylow H hp] [is_sylow K hp] :
	∃ g : G, H = conjugate_set g K 
	\end{lstlisting}
	\ls{dlogn p (card G)} ist die Vielfachheit von \ls{p} in \ls{card G}.\\\\
	\ls{#print axioms sylow.sylow_2} zeigt, dass \ls{propext}, \ls{quot.sound} und \ls{calssical.choice} verwendet wird.\\\\                                        
	\ls{quot.sound} wird benötigt, um zu beweisen, dass das kanonische Operieren einer Untergruppe \ls{H} auf den Nebenklassen einer Untergruppe \ls{K} eine Gruppenaktion ist:
	\begin{lstlisting}
	def mul_left_cosets (L₁ L₂ : set G) [is_subgroup L₂] [is_subgroup L₁]
	(x : L₂) (y : left_cosets L₁) : left_cosets L₁ :=
	quotient.lift_on y (λ y, $\lsem$(x : G) * y$\rsem$) 
	(λ a b (hab : _ ∈ L₁), quotient.sound 
	(show _ ∈ L₁, by rwa [mul_inv_rev, ← mul_assoc, mul_assoc (a⁻¹), inv_mul_self, mul_one]))
	\end{lstlisting}
	Dafür soll die Funktion \ls{(λ y, $\lsem$(x : G) * y$\rsem$)} auf Nebenklassen geliftet werden. Für zwei Elemente \ls{a} und \ls{b}, die bzgl. \ls{left_rel} äquivalent sind, ist also zu zeigen, dass
	\begin{lstlisting}
	$\lsem$(x : G) * a$\rsem$ = $\lsem$(x : G) * b$\rsem$.
	\end{lstlisting}
	Mit \ls{quot_sound} genügt dann ein Beweis dafür, dass die erzeugenden Elemente äquivalent sind. Die nötigen Umformungen erledigt \ls{simp}.
	
	Im Beweis von Sylow 2 werden zunächst die vorangegangenen Resultate verwendet, um herzuleiten, dass die Anzahl der Fixpunkte bzgl. obiger Aktion ungleich Null ist. An dieser Stelle liefert \ls{classical.choice} einen solchen Fixpunkt, ohne den die Konstruktion eines geeigneten \ls{conjugate_set} nicht möglich wäre.


	\subsection{Sylow 2 in Lean}
	Wir wollen nun auf einige Details im Beweis des Satzes eingehen. Die verwendeten Lemmata, die für das sukzessive Umformen via \ls{rw} oder \ls{simp} genutzt werden, sind dabei weder mathematisch noch hinsichtlich des Formalisierungsprozesses besonders interessant. Es werden zahlreiche technische Lemma über natürliche Zahlen, Kardinalitäten, Funktionen, etc. zusammengetragen, deren Beweise für den Menschen trivial und in Lean im Nachhinein teilweise nur sehr schwer verständlich sind. Es ist prinzipiell klar, dass es auf Basis der konstruierten Begriffe und Strukturen möglich ist, entsprechende Beweise für Lean verständlich zu formulieren und es genügt in der Regel zu wissen, dass sie existieren.
	
	Die ersten drei Hilfslemma liefern uns den gewünschten Fixpunkt.
	\begin{lstlisting}
	lemma sylow_2 [fintype G] {p : ℕ} (hp : nat.prime p)
	(H K : set G) [is_sylow H hp] [is_sylow K hp] :
	∃ g : G, H = conjugate_set g K :=
	
	have hs : card (left_cosets K) = card G / (p ^ dlogn p (card G)) := 
	(nat.mul_right_inj (pos_pow_of_pos (dlogn p (card G)) hp.pos)).1
	$\$$ by rw [ ← card_sylow K hp, ← card_eq_card_cosets_mul_card_subgroup, card_sylow K hp, 
	nat.div_mul_cancel (dlogn_dvd _ hp.1)],
	
	have hmodeq : card G / (p ^ dlogn p (card G)) ≡ card (fixed_points H (left_cosets K)) [MOD p] := 
	eq.subst hs (mul_action.card_modeq_card_fixed_points hp (card_sylow H hp)),
	
	have hfixed : 0 < card (fixed_points H (left_cosets K)) := 
	nat.pos_of_ne_zero 
	(λ h, (not_dvd_div_dlogn (fintype.card_pos_iff.2 ⟨(1 : G)⟩) hp.1) 
	(by rwa [h, nat.modeq.modeq_zero_iff] at hmodeq)),
	\end{lstlisting}
	Zunächst wird in \lstinline|hs| die Kardinalität der Klasse der Nebenklassen auf Basis der Definition von Sylow-Gruppen umgeformt. Hierbei wird das Lemma von Lagrange unter dem Namen \ls{card_eq_card_cosets_mul_card_subgroup} benutzt.
	
	In \ls{hmodeq} kommt die Lean-Version von Lemma (??) zur Anwendung: 
	\begin{lstlisting}
	lemma card_modeq_card_fixed_points [fintype α] [fintype G] 
	[fintype (fixed_points G α)]
	{p n : ℕ} (hp : nat.prime p) (h : card G = p ^ n) : 
	card α ≡ card (fixed_points G α) [MOD p]
	\end{lstlisting}
	Durch Substitution wird das allgemeine Resultat auf den Spezialfall übertragen.
	
	Mit Hilfe von \ls{hmodeq} lässt sich schließlich \ls{hfixed} zeigen, dass nämlich die Kardinalität der Fixpunkte größer Null ist. Nach \ls{nat.pos_of_ne_zero} genügt es zu zeigen, dass die Kardinalität der Fixpunkte ungleich Null ist. Es wird also ein Beweis von \ls{false} gefordert unter Annahme \ls{h}, die Kardinalität sei gleich Null. Der Widerspruch wird erzeugt, in dem erst 
	\begin{lstlisting}	
	lemma not_dvd_div_dlogn {p a : ℕ} (ha : a > 0) (hp : p > 1) : 
	¬p ∣ a / (p ^ dlogn p a)
	\end{lstlisting}
	auf \ls{a = card G} angewendet wird. Dass \ls{p} aber ein Teiler der rechten Seite sein muss, folgt aus der Annahme \ls{h} zusammen mit
	\begin{lstlisting}
	modeq_zero_iff : b ≡ 0 [MOD n] ↔ n ∣ b,
	\end{lstlisting}
	wobei \ls{b = card G / (p ^ dlogn p a)}.
	
	Um aus dem abstrakten Kardinalitäts-Argument einen konkreten Fixpunkt zu gewinnen, wird das Axiom \ls{classical.choice} in Form des Lemmas \ls{fintype.card_pos_iff} verwendet:
	\begin{lstlisting}
	let ⟨⟨x, hx⟩⟩ := fintype.card_pos_iff.1 hfixed in
	
	begin
	
	revert hx
	\end{lstlisting}
	Die Taktik \ls{revert} generalisiert den Beweis \ls{hx}, dass \ls{x} ein Fixpunkt ist, sodass nun folgendes zu beweisen ist:
	\begin{lstlisting}
	x ∈ fixed_points H (left_cosets K) → 
	(∃ (g : G), H = conjugate_set g K)
	\end{lstlisting}
	Der Grund dafür ist der, dass wir für die weitere Argumentation einen Vertreter \ls{g : G} für die Äquivalenzklasse \ls{x} benötigen. Dies wird möglich durch das Axiom \ls{quot.ind} in Form von \ls{quotient.induction_on}, nachdem es genügt, das Ziel für einen beliebigen Vertreter zu zeigen:
	\begin{lstlisting}
	refine quotient.induction_on x
	(λ g hg, ⟨g, set.eq_of_card_eq_of_subset _ _⟩)
	\end{lstlisting}
	Für ein Element \ls{g : G} und unter der Annahme \ls{hg}, dass \ls{$\lsem$g$\rsem$} ein Fixpunkt ist, bleibt nun die ursprünglich Aussage \ls{$\exists$(g : G), H = conjugate_set g K} zu zeigen.
	Dem anonymen Konstruktor wurde zur Konstruktion der Existenzaussage das Element \ls{g} und folgendes Lemma übergeben:
	\begin{lstlisting}
	lemma eq_of_card_eq_of_subset {s t : set α} [fintype s] [fintype t]
	(hcard : card s = card t) (hsub : s ⊆ t) : s = t
	\end{lstlisting}
	Durch die Verwendung der Taktik \ls{refine} und der zwei Unterstriche anstelle der Beweise \ls{hcard} und \ls{hsub}, werden diese Bedingungen als neue Ziele innerhalb des Taktik-Blocks erstellt, wobei das ursprüngliche Ziel als bewiesen gilt. Die beiden Beweise seien hier der Vollständigkeit halber aufgeführt, auch wenn die technischen Details nicht weiter interessant sind:
	\begin{lstlisting}
	{ 
	rw [conjugate_set_eq_image, set.card_image_of_injective _ conj_inj_left,
	card_sylow K hp, card_sylow H hp] },
	{
	assume y hy,
	have : (y⁻¹ * g)⁻¹ * g ∈ K := 
	quotient.exact ((mem_fixed_points' (left_cosets K)).1 hg $\lsem$y⁻¹ * g$\rsem$ 
	⟨⟨y⁻¹, inv_mem hy⟩, rfl⟩),
	simp [conjugate_set_eq_preimage], 
	simp only [*, mul_assoc, mul_inv_rev] at *,
	simp [*, inv_inv] at *}
	end
	\end{lstlisting}
\newpage
\section{Formalisierung in Naproche}
\section{Vergleich}
\section{Diskussion}
\section{Bibliographie}

\end{document}
